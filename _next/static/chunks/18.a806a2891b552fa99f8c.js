(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[18],{"92eX":function(e,t,n){"use strict";n.r(t),t.default='---\nslug: osdev-bootloader\ntitle: OS Dev Bootloader\ndescription: Learning about the bootloader and some common utilities.\nid: Operating System Development\ndate: 04-10-2021\n---\n\n---\n\n![Alt Text](https://images.unsplash.com/photo-1537498425277-c283d32ef9db?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1057&q=80)\n\n###### Photo by [Tianyi Ma]("https://unsplash.com/@tma?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText") on [Unsplash]("https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText")\n\n#### Preface\n\nAs we saw in the last section the bootloader can do some interesting things. So far all we\'ve done is display a simple message when we start up the emulator. We could do a lot more to it with interrupts and some assembly skills but stop and think for a minute, what can we really do with 512 bytes of memory. It\'s not a terribly small amount of space but it\'s definitely too small to do anything interesting or complicated like video memory, drivers, or anything else. What\'s the solution? A common practice is to use this space to jump start a second stage bootloader that will be much bigger than this. We are still restricted by memory that is already taken by BIOS and the maximum accessible memory caused by the CPU\'s 16-bit mode but it is going to be much more memory than we had before. So that\'s what we are going to do, load a second stage bootloader at memory location 0x9000 and jump to it from the intial bootloader. With a plan in mind let\'s move forward.\n\n#### Setting Up\n\nSo, before we start programming we need to go over some things we will use. The first of which is how to access hard drive sectors using Linear Block Addressing. \n\nThe Linear Block Address (LBA) is a nice way of accessing areas on our hard drive. It strips away the need to specify the head and track when accessing a memory address and allows us to access more memory than we could before. One thing to note is it automatically assumes that we have 512 byte sectors. Even if you don\'t have 512 byte sectors on your drive the BIOS and disk hardware should emulate it for you. The LBA structure is as follows:\n\n| Offset Range | Size | Description |\n| - | - | - |\n| 0x00 | 1 byte | Size of the Data Address Packet (Usually 0x10) |\n| 0x01 | 1 byte | Unused (Usually 0x00) |\n| 0x02 - 0x03 | 2 bytes | Number of sectors to be read from the hard disk |\n| 0x04 - 0x07 | 4 bytes | Segment:Offset pointer to the sector that contains the data we want to load |\n| 0x08 - 0x0F | 8 bytes | Absolute number of the starting sector to be read (1st sector is 0) |\n\n&nbsp;\n\n> ## Extra\n> There is also another way to address memory on a hard disk called Cylinder Head Sector (CHS). This is particularly useful for older devices like floppy disks that have no direct way of being accessed with LBA\'s. Luckily the name is pretty self-explanitory, we just need to specify the cylinder, the head, and the sector. BIOS will find this location for us on the hard drive and we can then read or write from that location as we wish.\n\n#### Loading From Memory\n\nLet\'s start by defining the variables we will need to load memory in our first bootloader. This will be an addition to what we had, however, I will also be changing a few things. If you added your own code I advise moving it to the second bootloader so we can safely stay under the 512 byte limit. What we are adding isn\'t that big but it\'s better to be safe than run over the memory limit unknowingly.\n\n```\n[bits 16]\n[org 0x7c00]\n\nmov [BOOT_DRIVE], dl\n\nmov bp, 0x8FFF\nmov sp, bp\n\nmov si, MSG_REAL_MODE\ncall printString_16\n\njmp $\n\n%include "printString_16.asm"\n\nSECONDBOOT_OFFSET: equ 0x9000\nBOOT_DRIVE: db 0\n\nLBA_SECONDBOOT:\n    ; Size of DAP\n    db 0x10\n    ; Unused\n    db 0x00\n    ; Number of sectors to be read\n    dw 0x01\n    ; Offset to the loaded location -x86 (little endian)\n    dw SECONDBOOT_OFFSET\n    dw 0x00\n    ; Absolute number of the start sector to be read\n    dd 0x01\n    dd 0x00\n\nMSG_REAL_MODE: db "Starting up in 16-bit Real Mode.", 0\nERROR_MSG: db "Error reading from disk.", 0\n\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nHere we\'ve added and changed a few things. Firstly we recorded what drive our bootloader started up on. This is automatically stored in the register dl when the computer is booted. Later on we will need to know this so we can load the correct information from the correct drive. Second we changed the stack location to 0x8FFF so the first byte of our stack does not overwrite the first byte of our next bootloader. Then we find something new `%include "printFunctions/printString_16.asm`. This is similar to any higher level language include and just copies that code at the location of the include. This will allow us to stop duplicating code and to make our files easier to read. If it wasn\'t clear you should now move the code for printing in 16 bit mode into it\'s own file named "printString_16.asm".\n\nNext we need to set up our code to actually tell the CPU to load the second bootloader into memory.\n\n```\n[bits 16]\n[org 0x7c00]\n\nmov [BOOT_DRIVE], dl\n\nmov bp, 0x8FFF\nmov sp, bp\n\nmov si, MSG_REAL_MODE\ncall printString_16\n\nloadSecondBoot:\n    ; SI - offset to the disk address packet\n    mov si, LBA_SECONDBOOT\n    ; AH - The subroutine for 0x13 - Extended read from disk\n    mov ah, 0x42\n    ; DL - Boot drive\n    mov dl, [BOOT_DRIVE]\n\n    ; Interrupt\n    int 0x13\n    jc diskReadFailed\n\n    jmp SECONDBOOT_OFFSET\n\ndiskReadFailed:\n    mov si, ERROR_MSG\n    call printString_16\n    jmp $\n\n%include "printString_16.asm"\n\nSECONDBOOT_OFFSET: equ 0x9000\nBOOT_DRIVE: db 0\n\nLBA_SECONDBOOT:\n    ; Size of DAP\n    db 0x10\n    ; Unused\n    db 0x00\n    ; Number of sectors to be read\n    dw 0x01\n    ; Offset to the loaded location -x86 (little endian)\n    dw SECONDBOOT_OFFSET\n    dw 0x00\n    ; Absolute number of the start sector to be read\n    dd 0x01\n    dd 0x00\n\nMSG_REAL_MODE: db "Starting up in 16-bit Real Mode.", 0\nERROR_MSG: db "Error reading from disk.", 0\n\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nWhat we added isn\'t that much but it gets us where we need to be. The first large addition is the `loadSecondBoot` label which loads the LBA info into SI, subroutine subfunction in AH, and the boot drive in DL. We then call the extended read from disk interrupt and check if anything went wrong by checking the carry bit. If nothing went wrong we jump to the beginning of the second bootloader, however, if something did go wrong we need to jump to the other label we added `diskReadFail`. This prints out an error message and jumps endlessly since we can\'t really do anything after that.\n\nSo now we have the initial bootloader and can start working on our second bootloader. This will look similar because initially we just want to print a simple message to verify that it worked correctly.\n\n```\n[bits 16]\n[org 0x9000]\n\n; Store the boot drive\nmov [BOOT_DRIVE], dl\n\n; Load a message and print\nmov si, SECOND_BOOT_MSG\ncall printString_16\n\njmp $\n\n; Includes\n%include "printString_16.asm"\n\nBOOT_DRIVE: db 0\nSECOND_BOOT_MSG: db "The second bootloader has been loaded!", 0\n```\n\nWe are officially prepared to start compiling and loading the files onto an img file. For one moment we need to shift gears into writing a program to write our binary files in the correct location to the img file. This can be done however you want but I\'m going to write a program in cpp that will work for both windows and unix. No matter how you do it the big thing to keep in mind is we need to specify the order and location of the files. The bootloader MUST go first and be exactly 512 bytes. The second bootloader can be wherever you want but you will need to tell the bootloader where it needs to load from.\n\n```cpp\n#include <array>\n#include <string>\n#include <iostream>\n#include <fstream>\n#include <filesystem>\n\n// Define all the needed files here in the correct order\nstd::array<std::string, 2> writeOrder = { "bootloader.asm", "secondboot.asm" };\n\nint main(int argc, char* argv[]) {\n    // Create or open the img file\n    std::ofstream imgFile("os.img", std::ios::binary);\n\n    bool found = false;\n    for (int i = 0; i < writeOrder.size(); i++ ) {\n        for (const auto& entry : std::filesystem::directory_iterator(".")) {\n            if (entry.path().string().substr(entry.path().string.find_last_of(\'/\') + 1) == writeOrder[i]) {\n                found = true;\n\n                // Compile the file\n                int subIndex = entry.path().string().find_last_of(\'/\') + 1;\n                system(std::string("nasm " + entry.path().string().substr(subIndex) + " -f bin -o " + entry.path().string().substr()(subIndex, entry.path().string().length() - subIndex - 4)).c_str());\n\n                // Write the compiled program to the img file\n                std::ifstream rf(entry.path().string().substr(0, entry.path().string().find_last_of(\'.\')), std::ios::binary | std::ios::in);\n                if (!rf) { std::cout << "Failed to open the file.\\n"; return -1; }\n                std::copy(std::istreambuf_iterator<char>(rf), std::istreambuf_iterator<char>( ), std::ostreambuf_iterator<char>(imgFile));\n\n                rf.close();\n\n                break;\n            }\n        }\n\n        if (found) continue;\n\n        std::cout << "One of the required files was not found.\\n";\n        return -1;\n    }\n\n    // Close the file\n    imgFile.close();\n\n    return 0;\n}\n```\n\nThis isn\'t the best way to do it and it can use some error checking but for simplicity sake this will do. Now you can set the writeOrder array to contain your file names in the correct order, compile the program, and run it. You should then be able to run:\n\n```\nqemu-system-x86_64 -drive format=raw,file=os.img\n```\n\nor if you\'re on windows:\n\n```\nqemu-system-x86_64 -L C:/Progra~1/qemu -drive format=raw,file=os.img\n```\n\nQemu should open up and you should see your two messages "Starting up in 16-bit Real Mode." and "The second bootloader has been loaded!". If you see an error about no bootable devices check that you are correctly writing the **binary data** to the img file.\n\n#### Conclusion\n\nNow we can add more code to our bootloader without worrying about the memory limit. It may seem like we aren\'t doing much with each addition but we are building up a strong base for adding some cool things in the future. As always take some time to mess around and see what you can do. The next topic we are going to cover is going into 32-bit protected mode and loading the kernel. It will be the most complicated thing we have done so far but it will be worth it. So be sure you are comfortable with the basics. As always if anything was confusing I suggest you research it some more as it might be imporant to understand later.\n\n\n[Return to the Posts Page](https://adisonyheathcott.github.io/adison_heathcott/posts)'}}]);