webpackHotUpdate_N_E(1,{

/***/ "./content/osdev-bootloader.md":
/*!*************************************!*\
  !*** ./content/osdev-bootloader.md ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"---\\nslug: osdev-bootloader\\ntitle: OS Dev Bootloader\\ndescription: Learning about the bootloader and some common utilities.\\nid: Operating System Development\\ndate: 04-10-2021\\n---\\n\\n---\\n\\n![Alt Text](https://images.unsplash.com/photo-1537498425277-c283d32ef9db?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1057&q=80)\\n\\n###### Photo by [Tianyi Ma](\\\"https://unsplash.com/@tma?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\\\") on [Unsplash](\\\"https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\\\")\\n\\n#### Preface\\n\\nAs we saw in the last section the bootloader can do some interesting things. So far all we've done is display a simple message when we start up the emulator. We could do a lot more to it with interrupts and some assembly skills but stop and think for a minute, what can we really do with 512 bytes of memory. It's not a terribly small amount of space but it's definitely too small to do anything interesting or complicated like video memory, drivers, or anything else. What's the solution? A common practice is to use this space to jump start a second stage bootloader that will be much bigger than this. We are still restricted by memory that is already taken by BIOS and the maximum accessible memory caused by the CPU's 16-bit mode but it is going to be much more memory than we had before. So that's what we are going to do, load a second stage bootloader at memory location 0x9000 and jump to it from the intial bootloader. With a plan in mind let's move forward.\\n\\n#### Setting Up\\n\\nSo, before we start programming we need to go over some things we will use. The first of which is how to access hard drive sectors using Linear Block Addressing. \\n\\nThe Linear Block Address (LBA) is a nice way of accessing areas on our hard drive. It strips away the need to specify the head and track when accessing a memory address and allows us to access more memory than we could before. One thing to note is it automatically assumes that we have 512 byte sectors. Even if you don't have 512 byte sectors on your drive the BIOS and disk hardware should emulate it for you. The LBA structure is as follows:\\n\\n| Offset Range | Size | Description |\\n| - | - | - |\\n| 0x00 | 1 byte | Size of the Data Address Packet (Usually 0x10) |\\n| 0x01 | 1 byte | Unused (Usually 0x00) |\\n| 0x02 - 0x03 | 2 bytes | Number of sectors to be read from the hard disk |\\n| 0x04 - 0x07 | 4 bytes | Segment:Offset pointer to the sector that contains the data we want to load |\\n| 0x08 - 0x0F | 8 bytes | Absolute number of the starting sector to be read (1st sector is 0) |\\n\\n&nbsp;\\n\\n> ## Extra\\n> There is also another way to address memory on a hard disk called Cylinder Head Sector (CHS). This is particularly useful for older devices like floppy disks that have no direct way of being accessed with LBA's. Luckily the name is pretty self-explanitory, we just need to specify the cylinder, the head, and the sector. BIOS will find this location for us on the hard drive and we can then read or write from that location as we wish.\\n\\n#### Loading From Memory\\n\\nLet's start by defining the variables we will need to load memory in our first bootloader. This will be an addition to what we had, however, I will also be changing a few things. If you added your own code I advise moving it to the second bootloader so we can safely stay under the 512 byte limit. What we are adding isn't that big but it's better to be safe than run over the memory limit unknowingly.\\n\\n```\\n[bits 16]\\n[org 0x7c00]\\n\\nmov [BOOT_DRIVE], dl\\n\\nmov bp, 0x8FFF\\nmov sp, bp\\n\\nmov si, MSG_REAL_MODE\\ncall printString_16\\n\\njmp $\\n\\n%include \\\"printString_16.asm\\\"\\n\\nSECONDBOOT_OFFSET: equ 0x9000\\nBOOT_DRIVE: db 0\\n\\nLBA_SECONDBOOT:\\n    ; Size of DAP\\n    db 0x10\\n    ; Unused\\n    db 0x00\\n    ; Number of sectors to be read\\n    dw 0x01\\n    ; Offset to the loaded location -x86 (little endian)\\n    dw SECONDBOOT_OFFSET\\n    dw 0x00\\n    ; Absolute number of the start sector to be read\\n    dd 0x01\\n    dd 0x00\\n\\nMSG_REAL_MODE: db \\\"Starting up in 16-bit Real Mode.\\\", 0\\nERROR_MSG: db \\\"Error reading from disk.\\\", 0\\n\\ntimes 510-($-$$) db 0\\ndw 0xaa55\\n```\\n\\nHere we've added and changed a few things. Firstly we recorded what drive our bootloader started up on. This is automatically stored in the register dl when the computer is booted. Later on we will need to know this so we can load the correct information from the correct drive. Second we changed the stack location to 0x8FFF so the first byte of our stack does not overwrite the first byte of our next bootloader. Then we find something new `%include \\\"printFunctions/printString_16.asm`. This is similar to any higher level language include and just copies that code at the location of the include. This will allow us to stop duplicating code and to make our files easier to read. If it wasn't clear you should now move the code for printing in 16 bit mode into it's own file named \\\"printString_16.asm\\\".\\n\\nNext we need to set up our code to actually tell the CPU to load the second bootloader into memory.\\n\\n```\\n[bits 16]\\n[org 0x7c00]\\n\\nmov [BOOT_DRIVE], dl\\n\\nmov bp, 0x8FFF\\nmov sp, bp\\n\\nmov si, MSG_REAL_MODE\\ncall printString_16\\n\\nloadSecondBoot:\\n    ; SI - offset to the disk address packet\\n    mov si, LBA_SECONDBOOT\\n    ; AH - The subroutine for 0x13 - Extended read from disk\\n    mov ah, 0x42\\n    ; DL - Boot drive\\n    mov dl, [BOOT_DRIVE]\\n\\n    ; Interrupt\\n    int 0x13\\n    jc diskReadFailed\\n\\n    jmp SECONDBOOT_OFFSET\\n\\ndiskReadFailed:\\n    mov si, ERROR_MSG\\n    call printString_16\\n    jmp $\\n\\n%include \\\"printString_16.asm\\\"\\n\\nSECONDBOOT_OFFSET: equ 0x9000\\nBOOT_DRIVE: db 0\\n\\nLBA_SECONDBOOT:\\n    ; Size of DAP\\n    db 0x10\\n    ; Unused\\n    db 0x00\\n    ; Number of sectors to be read\\n    dw 0x01\\n    ; Offset to the loaded location -x86 (little endian)\\n    dw SECONDBOOT_OFFSET\\n    dw 0x00\\n    ; Absolute number of the start sector to be read\\n    dd 0x01\\n    dd 0x00\\n\\nMSG_REAL_MODE: db \\\"Starting up in 16-bit Real Mode.\\\", 0\\nERROR_MSG: db \\\"Error reading from disk.\\\", 0\\n\\ntimes 510-($-$$) db 0\\ndw 0xaa55\\n```\\n\\nWhat we added isn't that much but it gets us where we need to be. The first large addition is the `loadSecondBoot` label which loads the LBA info into SI, subroutine subfunction in AH, and the boot drive in DL. We then call the extended read from disk interrupt and check if anything went wrong by checking the carry bit. If nothing went wrong we jump to the beginning of the second bootloader, however, if something did go wrong we need to jump to the other label we added `diskReadFail`. This prints out an error message and jumps endlessly since we can't really do anything after that.\\n\\nSo now we have the initial bootloader and can start working on our second bootloader. This will look similar because initially we just want to print a simple message to verify that it worked correctly.\\n\\n```\\n[bits 16]\\n[org 0x9000]\\n\\n; Store the boot drive\\nmov [BOOT_DRIVE], dl\\n\\n; Load a message and print\\nmov si, SECOND_BOOT_MSG\\ncall printString_16\\n\\njmp $\\n\\n; Includes\\n%include \\\"printString_16.asm\\\"\\n\\nBOOT_DRIVE: db 0\\nSECOND_BOOT_MSG: db \\\"The second bootloader has been loaded!\\\", 0\\n```\\n\\nWe are officially prepared to start compiling and loading the files onto an img file. For one moment we need to shift gears into writing a program to write our binary files in the correct location to the img file. This can be done however you want but I'm going to write a program in cpp that will work for both windows and unix. No matter how you do it the big thing to keep in mind is we need to specify the order and location of the files. The bootloader MUST go first and be exactly 512 bytes. The second bootloader can be wherever you want but you will need to tell the bootloader where it needs to load from.\\n\\n```cpp\\n#include <array>\\n#include <string>\\n#include <iostream>\\n#include <fstream>\\n#include <filesystem>\\n\\n// Define all the needed files here in the correct order\\nstd::array<std::string, 2> writeOrder = { \\\"bootloader.asm\\\", \\\"secondboot.asm\\\" };\\n\\nint main(int argc, char* argv[]) {\\n    // Create or open the img file\\n    std::ofstream imgFile(\\\"os.img\\\", std::ios::binary);\\n\\n    bool found = false;\\n    for (int i = 0; i < writeOrder.size(); i++ ) {\\n        for (const auto& entry : std::filesystem::directory_iterator(\\\".\\\")) {\\n            if (entry.path().string().substr(entry.path().string.find_last_of('/') + 1) == writeOrder[i]) {\\n                found = true;\\n\\n                // Compile the file\\n                int subIndex = entry.path().string().find_last_of('/') + 1;\\n                system(std::string(\\\"nasm \\\" + entry.path().string().substr(subIndex) + \\\" -f bin -o \\\" + entry.path().string().substr()(subIndex, entry.path().string().length() - subIndex - 4)).c_str());\\n\\n                // Write the compiled program to the img file\\n                std::ifstream rf(entry.path(), std::ios::binary);\\n\\n                break;\\n            }\\n        }\\n\\n        if (found) continue;\\n\\n        std::cout << \\\"One of the required files was not found.\\\\n\\\";\\n        return -1;\\n    }\\n\\n    // Close the file\\n    imgFile.close();\\n\\n    return 0;\\n}\\n```\\n\\n\\n<!-- \\nSo, we programmed our bootloader in the last section, but for our new plan we will need to add more to it. Since we've seen some of this before I'm going to be more sparse with the comments.\\n\\n```\\n[bits 16]\\n[org 0x7c00]\\n\\n; Our code will go here\\n\\nmov bp, 0x8FFF\\t\\t\\t; Set the base pointer at 0x8FFF\\nmov sp, bp\\t\\t\\t\\t; Set the stack pointer at the base\\n\\nmov si, MSG_REAL_MODE\\t; Move the pointer to the first character to si\\ncall printString_16\\t\\t; Call the print string function\\n\\njmp $\\t\\t\\t\\t\\t; Endlessly jump on this line of code\\n\\n-- PRINT FUNCTION DEFINED HERE --\\n\\nSECONDBOOT_OFFSET: equ 0x9000\\nBOOT_DRIVE: db 0\\n\\nLBA_SECONDBOOT:\\n    ; Size of DAP\\n    db 0x10\\n    ; Unused\\n    db 0x00\\n    ; Number of sectors to be read\\n    dw 0x01\\n    ; Offset to the loaded location -x86 (little endian)\\n    dw SECONDBOOT_OFFSET\\n    dw 0x00\\n    ; Absolute number of the start sector to be read\\n    dd 0x01\\n    dd 0x00\\n\\nMSG_REAL_MODE:  db \\\"Starting up in 16-bit Real Mode.\\\", 0\\nERROR_MSG:      db \\\"Error reading from disk.\\\", 0\\n\\ntimes 510-($-$$) db 0\\ndw 0xaa55\\n```\\n\\nHere we changed a few things that are important. First, we changed the stack location to 0x8FFF so that it wouldn't start on the first byte of our second stage bootloader. Second, we defined two directives called BOOT_DRIVE and SECONDBOOT_OFFSET. BOOT_DRIVE holds information about our boot disk that we will need to our second bootloader. SECONDBOOT_OFFSET will define the location where we want to load the second bootloader in memory. Memory location 0x9000 will give us much more memory for the bootloader and works as long as we do not pass memory location 0x7FFFF.\\n\\nThe Linear Block Address (LBA) is a nice way of accessing areas on our hard drive. It strips away the need to specify the head and track when accessing a memory address and assumes we have 512 byte sectors. Even if you don't have 512 byte sectors on your drive the BIOS and disk hardware should emulate it for you.\\n\\nHopefully you recognize the assembly instructions we used for this structure, if not the simple rundown is db is declare byte, dw is declare word, and dd is declare double word. We start by defining the Disk Address Packet (DAP) which will make loading that much easier. The definition is as follows:\\n\\n1 byte - Size of the packet (Always set to 0x10)\\n\\n1 byte - Unused (Set this to 0x00)\\n\\n2 bytes - The number of sectors to read from the hard drive\\n\\n4 bytes - The segment:offset pointer to memory buffer\\n\\n8 bytes - The absolute number of the start sector to read from\\n\\n> ## Extra\\n> There is also another way to address memory on a hard disk called Cylinder Head Sector (CHS). This is particularly useful for older devices like floppy disks that have no direct way of being accessed with LBA's. Luckily the name is pretty self-explanitory, we just need to specify the cylinder, the head, and the sector. BIOS will find this location for us on the hard drive and we can then read or write from that location as we wish.\\n\\nWe will see how this is used when we call the interrupt itself. To save space I won't show the entire file all the time but I will try and define something that was previously defined so you know where to start and end. These additions will be a great base for the rest of our program.\\n\\n#### Loading Files\\n\\n```\\n; Store the boot location into BOOT_DRIVE\\nmov [BOOT_DRIVE], dl\\n\\n; Set up the stack location at 0x8FFF\\nmov bp, 0x8FFF  ; Set the base stack pointer\\nmov sp, bp      ; Set the stack pointer\\n\\nmov si, MSG_REAL_MODE\\ncall printString_16\\n\\nloadSecondBoot:\\n    ; SI - offset to the disk address packet\\n    mov si, LBA_SECONDBOOT\\n    ; AH - The subroutine for 0x13 - Extended read from disk\\n    mov ah, 0x42\\n    ; DL - Boot drive\\n    mov dl, [BOOT_DRIVE]\\n\\n    ; Interrupt\\n    int 0x13\\n    jc diskReadFailed\\n\\n    jmp SECONDBOOT_OFFSET\\n\\ndiskReadFailed:\\n    mov si, ERROR_MSG\\n    call printString_16\\n    jmp $\\n\\n-- PRINT FUNCTION DEFINED HERE --\\n\\n```\\n\\nA quick note before we get into the bulk of the addition. At the beginning of our bootloader we have now added an instruction to store the boot drive in a variable. Whenever we start up our computer the drive that we loaded the bootloader from will have it's id stored in the dl register. We need to save this for later.\\n\\nNow we have added the actual functionality that will allow us to load our second bootloader from the disk. We added the labels `loadSecondBoot` and `diskReadFailed` to help us organize our program. In case you are unaware the `loadSecondBoot:` is a label. This allows us to define certain locations in memory almost like functions in c or c++. This won't actually be added into our program but will allow the assembler to replace any occurances of this label with the correct location in memory. So if we wrote `jmp loadSecondBoot` the program would replace loadSecondBoot with the location in memory where the label is defined and jump to that location where it will continue to execute instructions. First we will go over the loadSecondBoot label.\\n\\nThe first instruction under the `loadSecondBoot` label is where we get to set up the LBA_SECONDBOOT structure before we use it. This will be crucial in telling the BIOS where to look for the memory we want. Remember that the LBA structure holds the starting sector of our data, the size of the data, and the location where we want to load it into RAM. Next we load the subroutine 0x13 into the register ah like we did before with the print interrupt. Now is where we use the BOOT_DRIVE we were saving earlier. This will tell the BIOS what device we want to search for the memory on. Next we actually call the interrupt to load the file and jump to `diskReadFailed` if the carry flag is set. By looking at the interrupts documentation we know that if anything went wrong while trying to read from the disk it would set this flag to let us know. Finally if all is well we jump to the memory location where we loaded our second bootloader.\\n\\nThe second label defines a short set of instructions that handles errors that may occur while trying to read the disk. This is the exact same as the instructions we used to print our first message, only this time we will print an error message.\\n\\nAmazingly that is all we need to load a chunk of memory from the disk onto RAM. Now it is time to write the second bootloader. For this we will just make a super simple bootloader that prints a small message. We've seen how to do this before but I'll put it below because I plan on changing a few things.\\n\\n```\\n[bits 16]\\n[org 0x9000]\\n\\n; Store the boot drive\\nmov [BOOT_DRIVE], dl\\n\\nmov si, MSG_SECOND_BOOT     ; Move the pointer to the first character to si\\ncall printString_16         ; Call the print string function\\n\\njmp $                       ; Endlessly jump on this line\\n\\n%include \\\"printFunctions/printString16.asm\\\"\\n\\nBOOT_DRIVE: db 0\\nMSG_SECOND_BOOT: \\\"Loaded the second bootloader\\\", 0\\n```\\n\\nHere we have a very similar bootloader to what we had originally \\n\\n#### Conclusion\\n\\n\\n[Return to the Posts Page](https://adisonyheathcott.github.io/adison_heathcott/posts) -->\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGVudC9vc2Rldi1ib290bG9hZGVyLm1kPzlmMDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBZSxpZ0JBQWtjLHdCQUF3Qiw2R0FBNkcsd0JBQXdCLDBqRUFBMGpFLG9uQ0FBb25DLGdDQUFnQywyQkFBMkIsaURBQWlELGlHQUFpRyw4d0NBQTh3QywwRUFBMEUsZ0ZBQWdGLG1EQUFtRCwwUUFBMFEsZ0NBQWdDLDJCQUEyQixpREFBaUQsaUdBQWlHLGdpQ0FBZ2lDLGdEQUFnRCxxRkFBcUYsczhCQUFzOEIsMENBQTBDLHNDQUFzQyw4RkFBOEYsMkJBQTJCLHFCQUFxQix1QkFBdUIsUUFBUSxnRkFBZ0YsNkdBQTZHLCtCQUErQixvSEFBb0gsOE1BQThNLG9JQUFvSSwwQkFBMEIsZUFBZSxXQUFXLGdDQUFnQyx5RUFBeUUsb0JBQW9CLE9BQU8sK0NBQStDLGlCQUFpQixHQUFHLHFQQUFxUCwrQ0FBK0Msb0RBQW9ELDhEQUE4RCx3RUFBd0UsbURBQW1ELHNKQUFzSixnQ0FBZ0MsMkJBQTJCLGlEQUFpRCxpR0FBaUcsMDZFQUEwNkUsbUVBQW1FLHVEQUF1RCw4Q0FBOEMsOEZBQThGLDBFQUEwRSxnRkFBZ0YsbURBQW1ELHd2RkFBd3ZGLDRFQUE0RSw2RUFBNkUsZ0VBQWdFLG9WQUFvViIsImZpbGUiOiIuL2NvbnRlbnQvb3NkZXYtYm9vdGxvYWRlci5tZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiLS0tXFxuc2x1Zzogb3NkZXYtYm9vdGxvYWRlclxcbnRpdGxlOiBPUyBEZXYgQm9vdGxvYWRlclxcbmRlc2NyaXB0aW9uOiBMZWFybmluZyBhYm91dCB0aGUgYm9vdGxvYWRlciBhbmQgc29tZSBjb21tb24gdXRpbGl0aWVzLlxcbmlkOiBPcGVyYXRpbmcgU3lzdGVtIERldmVsb3BtZW50XFxuZGF0ZTogMDQtMTAtMjAyMVxcbi0tLVxcblxcbi0tLVxcblxcbiFbQWx0IFRleHRdKGh0dHBzOi8vaW1hZ2VzLnVuc3BsYXNoLmNvbS9waG90by0xNTM3NDk4NDI1Mjc3LWMyODNkMzJlZjlkYj9peGlkPU1Yd3hNakEzZkRCOE1IeHdhRzkwYnkxd1lXZGxmSHg4ZkdWdWZEQjhmSHclM0QmaXhsaWI9cmItMS4yLjEmYXV0bz1mb3JtYXQmZml0PWNyb3Amdz0xMDU3JnE9ODApXFxuXFxuIyMjIyMjIFBob3RvIGJ5IFtUaWFueWkgTWFdKFxcXCJodHRwczovL3Vuc3BsYXNoLmNvbS9AdG1hP3V0bV9zb3VyY2U9dW5zcGxhc2gmYW1wO3V0bV9tZWRpdW09cmVmZXJyYWwmYW1wO3V0bV9jb250ZW50PWNyZWRpdENvcHlUZXh0XFxcIikgb24gW1Vuc3BsYXNoXShcXFwiaHR0cHM6Ly91bnNwbGFzaC5jb20vcy9waG90b3MvY29tcHV0ZXI/dXRtX3NvdXJjZT11bnNwbGFzaCZhbXA7dXRtX21lZGl1bT1yZWZlcnJhbCZhbXA7dXRtX2NvbnRlbnQ9Y3JlZGl0Q29weVRleHRcXFwiKVxcblxcbiMjIyMgUHJlZmFjZVxcblxcbkFzIHdlIHNhdyBpbiB0aGUgbGFzdCBzZWN0aW9uIHRoZSBib290bG9hZGVyIGNhbiBkbyBzb21lIGludGVyZXN0aW5nIHRoaW5ncy4gU28gZmFyIGFsbCB3ZSd2ZSBkb25lIGlzIGRpc3BsYXkgYSBzaW1wbGUgbWVzc2FnZSB3aGVuIHdlIHN0YXJ0IHVwIHRoZSBlbXVsYXRvci4gV2UgY291bGQgZG8gYSBsb3QgbW9yZSB0byBpdCB3aXRoIGludGVycnVwdHMgYW5kIHNvbWUgYXNzZW1ibHkgc2tpbGxzIGJ1dCBzdG9wIGFuZCB0aGluayBmb3IgYSBtaW51dGUsIHdoYXQgY2FuIHdlIHJlYWxseSBkbyB3aXRoIDUxMiBieXRlcyBvZiBtZW1vcnkuIEl0J3Mgbm90IGEgdGVycmlibHkgc21hbGwgYW1vdW50IG9mIHNwYWNlIGJ1dCBpdCdzIGRlZmluaXRlbHkgdG9vIHNtYWxsIHRvIGRvIGFueXRoaW5nIGludGVyZXN0aW5nIG9yIGNvbXBsaWNhdGVkIGxpa2UgdmlkZW8gbWVtb3J5LCBkcml2ZXJzLCBvciBhbnl0aGluZyBlbHNlLiBXaGF0J3MgdGhlIHNvbHV0aW9uPyBBIGNvbW1vbiBwcmFjdGljZSBpcyB0byB1c2UgdGhpcyBzcGFjZSB0byBqdW1wIHN0YXJ0IGEgc2Vjb25kIHN0YWdlIGJvb3Rsb2FkZXIgdGhhdCB3aWxsIGJlIG11Y2ggYmlnZ2VyIHRoYW4gdGhpcy4gV2UgYXJlIHN0aWxsIHJlc3RyaWN0ZWQgYnkgbWVtb3J5IHRoYXQgaXMgYWxyZWFkeSB0YWtlbiBieSBCSU9TIGFuZCB0aGUgbWF4aW11bSBhY2Nlc3NpYmxlIG1lbW9yeSBjYXVzZWQgYnkgdGhlIENQVSdzIDE2LWJpdCBtb2RlIGJ1dCBpdCBpcyBnb2luZyB0byBiZSBtdWNoIG1vcmUgbWVtb3J5IHRoYW4gd2UgaGFkIGJlZm9yZS4gU28gdGhhdCdzIHdoYXQgd2UgYXJlIGdvaW5nIHRvIGRvLCBsb2FkIGEgc2Vjb25kIHN0YWdlIGJvb3Rsb2FkZXIgYXQgbWVtb3J5IGxvY2F0aW9uIDB4OTAwMCBhbmQganVtcCB0byBpdCBmcm9tIHRoZSBpbnRpYWwgYm9vdGxvYWRlci4gV2l0aCBhIHBsYW4gaW4gbWluZCBsZXQncyBtb3ZlIGZvcndhcmQuXFxuXFxuIyMjIyBTZXR0aW5nIFVwXFxuXFxuU28sIGJlZm9yZSB3ZSBzdGFydCBwcm9ncmFtbWluZyB3ZSBuZWVkIHRvIGdvIG92ZXIgc29tZSB0aGluZ3Mgd2Ugd2lsbCB1c2UuIFRoZSBmaXJzdCBvZiB3aGljaCBpcyBob3cgdG8gYWNjZXNzIGhhcmQgZHJpdmUgc2VjdG9ycyB1c2luZyBMaW5lYXIgQmxvY2sgQWRkcmVzc2luZy4gXFxuXFxuVGhlIExpbmVhciBCbG9jayBBZGRyZXNzIChMQkEpIGlzIGEgbmljZSB3YXkgb2YgYWNjZXNzaW5nIGFyZWFzIG9uIG91ciBoYXJkIGRyaXZlLiBJdCBzdHJpcHMgYXdheSB0aGUgbmVlZCB0byBzcGVjaWZ5IHRoZSBoZWFkIGFuZCB0cmFjayB3aGVuIGFjY2Vzc2luZyBhIG1lbW9yeSBhZGRyZXNzIGFuZCBhbGxvd3MgdXMgdG8gYWNjZXNzIG1vcmUgbWVtb3J5IHRoYW4gd2UgY291bGQgYmVmb3JlLiBPbmUgdGhpbmcgdG8gbm90ZSBpcyBpdCBhdXRvbWF0aWNhbGx5IGFzc3VtZXMgdGhhdCB3ZSBoYXZlIDUxMiBieXRlIHNlY3RvcnMuIEV2ZW4gaWYgeW91IGRvbid0IGhhdmUgNTEyIGJ5dGUgc2VjdG9ycyBvbiB5b3VyIGRyaXZlIHRoZSBCSU9TIGFuZCBkaXNrIGhhcmR3YXJlIHNob3VsZCBlbXVsYXRlIGl0IGZvciB5b3UuIFRoZSBMQkEgc3RydWN0dXJlIGlzIGFzIGZvbGxvd3M6XFxuXFxufCBPZmZzZXQgUmFuZ2UgfCBTaXplIHwgRGVzY3JpcHRpb24gfFxcbnwgLSB8IC0gfCAtIHxcXG58IDB4MDAgfCAxIGJ5dGUgfCBTaXplIG9mIHRoZSBEYXRhIEFkZHJlc3MgUGFja2V0IChVc3VhbGx5IDB4MTApIHxcXG58IDB4MDEgfCAxIGJ5dGUgfCBVbnVzZWQgKFVzdWFsbHkgMHgwMCkgfFxcbnwgMHgwMiAtIDB4MDMgfCAyIGJ5dGVzIHwgTnVtYmVyIG9mIHNlY3RvcnMgdG8gYmUgcmVhZCBmcm9tIHRoZSBoYXJkIGRpc2sgfFxcbnwgMHgwNCAtIDB4MDcgfCA0IGJ5dGVzIHwgU2VnbWVudDpPZmZzZXQgcG9pbnRlciB0byB0aGUgc2VjdG9yIHRoYXQgY29udGFpbnMgdGhlIGRhdGEgd2Ugd2FudCB0byBsb2FkIHxcXG58IDB4MDggLSAweDBGIHwgOCBieXRlcyB8IEFic29sdXRlIG51bWJlciBvZiB0aGUgc3RhcnRpbmcgc2VjdG9yIHRvIGJlIHJlYWQgKDFzdCBzZWN0b3IgaXMgMCkgfFxcblxcbiZuYnNwO1xcblxcbj4gIyMgRXh0cmFcXG4+IFRoZXJlIGlzIGFsc28gYW5vdGhlciB3YXkgdG8gYWRkcmVzcyBtZW1vcnkgb24gYSBoYXJkIGRpc2sgY2FsbGVkIEN5bGluZGVyIEhlYWQgU2VjdG9yIChDSFMpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG9sZGVyIGRldmljZXMgbGlrZSBmbG9wcHkgZGlza3MgdGhhdCBoYXZlIG5vIGRpcmVjdCB3YXkgb2YgYmVpbmcgYWNjZXNzZWQgd2l0aCBMQkEncy4gTHVja2lseSB0aGUgbmFtZSBpcyBwcmV0dHkgc2VsZi1leHBsYW5pdG9yeSwgd2UganVzdCBuZWVkIHRvIHNwZWNpZnkgdGhlIGN5bGluZGVyLCB0aGUgaGVhZCwgYW5kIHRoZSBzZWN0b3IuIEJJT1Mgd2lsbCBmaW5kIHRoaXMgbG9jYXRpb24gZm9yIHVzIG9uIHRoZSBoYXJkIGRyaXZlIGFuZCB3ZSBjYW4gdGhlbiByZWFkIG9yIHdyaXRlIGZyb20gdGhhdCBsb2NhdGlvbiBhcyB3ZSB3aXNoLlxcblxcbiMjIyMgTG9hZGluZyBGcm9tIE1lbW9yeVxcblxcbkxldCdzIHN0YXJ0IGJ5IGRlZmluaW5nIHRoZSB2YXJpYWJsZXMgd2Ugd2lsbCBuZWVkIHRvIGxvYWQgbWVtb3J5IGluIG91ciBmaXJzdCBib290bG9hZGVyLiBUaGlzIHdpbGwgYmUgYW4gYWRkaXRpb24gdG8gd2hhdCB3ZSBoYWQsIGhvd2V2ZXIsIEkgd2lsbCBhbHNvIGJlIGNoYW5naW5nIGEgZmV3IHRoaW5ncy4gSWYgeW91IGFkZGVkIHlvdXIgb3duIGNvZGUgSSBhZHZpc2UgbW92aW5nIGl0IHRvIHRoZSBzZWNvbmQgYm9vdGxvYWRlciBzbyB3ZSBjYW4gc2FmZWx5IHN0YXkgdW5kZXIgdGhlIDUxMiBieXRlIGxpbWl0LiBXaGF0IHdlIGFyZSBhZGRpbmcgaXNuJ3QgdGhhdCBiaWcgYnV0IGl0J3MgYmV0dGVyIHRvIGJlIHNhZmUgdGhhbiBydW4gb3ZlciB0aGUgbWVtb3J5IGxpbWl0IHVua25vd2luZ2x5LlxcblxcbmBgYFxcbltiaXRzIDE2XVxcbltvcmcgMHg3YzAwXVxcblxcbm1vdiBbQk9PVF9EUklWRV0sIGRsXFxuXFxubW92IGJwLCAweDhGRkZcXG5tb3Ygc3AsIGJwXFxuXFxubW92IHNpLCBNU0dfUkVBTF9NT0RFXFxuY2FsbCBwcmludFN0cmluZ18xNlxcblxcbmptcCAkXFxuXFxuJWluY2x1ZGUgXFxcInByaW50U3RyaW5nXzE2LmFzbVxcXCJcXG5cXG5TRUNPTkRCT09UX09GRlNFVDogZXF1IDB4OTAwMFxcbkJPT1RfRFJJVkU6IGRiIDBcXG5cXG5MQkFfU0VDT05EQk9PVDpcXG4gICAgOyBTaXplIG9mIERBUFxcbiAgICBkYiAweDEwXFxuICAgIDsgVW51c2VkXFxuICAgIGRiIDB4MDBcXG4gICAgOyBOdW1iZXIgb2Ygc2VjdG9ycyB0byBiZSByZWFkXFxuICAgIGR3IDB4MDFcXG4gICAgOyBPZmZzZXQgdG8gdGhlIGxvYWRlZCBsb2NhdGlvbiAteDg2IChsaXR0bGUgZW5kaWFuKVxcbiAgICBkdyBTRUNPTkRCT09UX09GRlNFVFxcbiAgICBkdyAweDAwXFxuICAgIDsgQWJzb2x1dGUgbnVtYmVyIG9mIHRoZSBzdGFydCBzZWN0b3IgdG8gYmUgcmVhZFxcbiAgICBkZCAweDAxXFxuICAgIGRkIDB4MDBcXG5cXG5NU0dfUkVBTF9NT0RFOiBkYiBcXFwiU3RhcnRpbmcgdXAgaW4gMTYtYml0IFJlYWwgTW9kZS5cXFwiLCAwXFxuRVJST1JfTVNHOiBkYiBcXFwiRXJyb3IgcmVhZGluZyBmcm9tIGRpc2suXFxcIiwgMFxcblxcbnRpbWVzIDUxMC0oJC0kJCkgZGIgMFxcbmR3IDB4YWE1NVxcbmBgYFxcblxcbkhlcmUgd2UndmUgYWRkZWQgYW5kIGNoYW5nZWQgYSBmZXcgdGhpbmdzLiBGaXJzdGx5IHdlIHJlY29yZGVkIHdoYXQgZHJpdmUgb3VyIGJvb3Rsb2FkZXIgc3RhcnRlZCB1cCBvbi4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IHN0b3JlZCBpbiB0aGUgcmVnaXN0ZXIgZGwgd2hlbiB0aGUgY29tcHV0ZXIgaXMgYm9vdGVkLiBMYXRlciBvbiB3ZSB3aWxsIG5lZWQgdG8ga25vdyB0aGlzIHNvIHdlIGNhbiBsb2FkIHRoZSBjb3JyZWN0IGluZm9ybWF0aW9uIGZyb20gdGhlIGNvcnJlY3QgZHJpdmUuIFNlY29uZCB3ZSBjaGFuZ2VkIHRoZSBzdGFjayBsb2NhdGlvbiB0byAweDhGRkYgc28gdGhlIGZpcnN0IGJ5dGUgb2Ygb3VyIHN0YWNrIGRvZXMgbm90IG92ZXJ3cml0ZSB0aGUgZmlyc3QgYnl0ZSBvZiBvdXIgbmV4dCBib290bG9hZGVyLiBUaGVuIHdlIGZpbmQgc29tZXRoaW5nIG5ldyBgJWluY2x1ZGUgXFxcInByaW50RnVuY3Rpb25zL3ByaW50U3RyaW5nXzE2LmFzbWAuIFRoaXMgaXMgc2ltaWxhciB0byBhbnkgaGlnaGVyIGxldmVsIGxhbmd1YWdlIGluY2x1ZGUgYW5kIGp1c3QgY29waWVzIHRoYXQgY29kZSBhdCB0aGUgbG9jYXRpb24gb2YgdGhlIGluY2x1ZGUuIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBzdG9wIGR1cGxpY2F0aW5nIGNvZGUgYW5kIHRvIG1ha2Ugb3VyIGZpbGVzIGVhc2llciB0byByZWFkLiBJZiBpdCB3YXNuJ3QgY2xlYXIgeW91IHNob3VsZCBub3cgbW92ZSB0aGUgY29kZSBmb3IgcHJpbnRpbmcgaW4gMTYgYml0IG1vZGUgaW50byBpdCdzIG93biBmaWxlIG5hbWVkIFxcXCJwcmludFN0cmluZ18xNi5hc21cXFwiLlxcblxcbk5leHQgd2UgbmVlZCB0byBzZXQgdXAgb3VyIGNvZGUgdG8gYWN0dWFsbHkgdGVsbCB0aGUgQ1BVIHRvIGxvYWQgdGhlIHNlY29uZCBib290bG9hZGVyIGludG8gbWVtb3J5LlxcblxcbmBgYFxcbltiaXRzIDE2XVxcbltvcmcgMHg3YzAwXVxcblxcbm1vdiBbQk9PVF9EUklWRV0sIGRsXFxuXFxubW92IGJwLCAweDhGRkZcXG5tb3Ygc3AsIGJwXFxuXFxubW92IHNpLCBNU0dfUkVBTF9NT0RFXFxuY2FsbCBwcmludFN0cmluZ18xNlxcblxcbmxvYWRTZWNvbmRCb290OlxcbiAgICA7IFNJIC0gb2Zmc2V0IHRvIHRoZSBkaXNrIGFkZHJlc3MgcGFja2V0XFxuICAgIG1vdiBzaSwgTEJBX1NFQ09OREJPT1RcXG4gICAgOyBBSCAtIFRoZSBzdWJyb3V0aW5lIGZvciAweDEzIC0gRXh0ZW5kZWQgcmVhZCBmcm9tIGRpc2tcXG4gICAgbW92IGFoLCAweDQyXFxuICAgIDsgREwgLSBCb290IGRyaXZlXFxuICAgIG1vdiBkbCwgW0JPT1RfRFJJVkVdXFxuXFxuICAgIDsgSW50ZXJydXB0XFxuICAgIGludCAweDEzXFxuICAgIGpjIGRpc2tSZWFkRmFpbGVkXFxuXFxuICAgIGptcCBTRUNPTkRCT09UX09GRlNFVFxcblxcbmRpc2tSZWFkRmFpbGVkOlxcbiAgICBtb3Ygc2ksIEVSUk9SX01TR1xcbiAgICBjYWxsIHByaW50U3RyaW5nXzE2XFxuICAgIGptcCAkXFxuXFxuJWluY2x1ZGUgXFxcInByaW50U3RyaW5nXzE2LmFzbVxcXCJcXG5cXG5TRUNPTkRCT09UX09GRlNFVDogZXF1IDB4OTAwMFxcbkJPT1RfRFJJVkU6IGRiIDBcXG5cXG5MQkFfU0VDT05EQk9PVDpcXG4gICAgOyBTaXplIG9mIERBUFxcbiAgICBkYiAweDEwXFxuICAgIDsgVW51c2VkXFxuICAgIGRiIDB4MDBcXG4gICAgOyBOdW1iZXIgb2Ygc2VjdG9ycyB0byBiZSByZWFkXFxuICAgIGR3IDB4MDFcXG4gICAgOyBPZmZzZXQgdG8gdGhlIGxvYWRlZCBsb2NhdGlvbiAteDg2IChsaXR0bGUgZW5kaWFuKVxcbiAgICBkdyBTRUNPTkRCT09UX09GRlNFVFxcbiAgICBkdyAweDAwXFxuICAgIDsgQWJzb2x1dGUgbnVtYmVyIG9mIHRoZSBzdGFydCBzZWN0b3IgdG8gYmUgcmVhZFxcbiAgICBkZCAweDAxXFxuICAgIGRkIDB4MDBcXG5cXG5NU0dfUkVBTF9NT0RFOiBkYiBcXFwiU3RhcnRpbmcgdXAgaW4gMTYtYml0IFJlYWwgTW9kZS5cXFwiLCAwXFxuRVJST1JfTVNHOiBkYiBcXFwiRXJyb3IgcmVhZGluZyBmcm9tIGRpc2suXFxcIiwgMFxcblxcbnRpbWVzIDUxMC0oJC0kJCkgZGIgMFxcbmR3IDB4YWE1NVxcbmBgYFxcblxcbldoYXQgd2UgYWRkZWQgaXNuJ3QgdGhhdCBtdWNoIGJ1dCBpdCBnZXRzIHVzIHdoZXJlIHdlIG5lZWQgdG8gYmUuIFRoZSBmaXJzdCBsYXJnZSBhZGRpdGlvbiBpcyB0aGUgYGxvYWRTZWNvbmRCb290YCBsYWJlbCB3aGljaCBsb2FkcyB0aGUgTEJBIGluZm8gaW50byBTSSwgc3Vicm91dGluZSBzdWJmdW5jdGlvbiBpbiBBSCwgYW5kIHRoZSBib290IGRyaXZlIGluIERMLiBXZSB0aGVuIGNhbGwgdGhlIGV4dGVuZGVkIHJlYWQgZnJvbSBkaXNrIGludGVycnVwdCBhbmQgY2hlY2sgaWYgYW55dGhpbmcgd2VudCB3cm9uZyBieSBjaGVja2luZyB0aGUgY2FycnkgYml0LiBJZiBub3RoaW5nIHdlbnQgd3Jvbmcgd2UganVtcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgYm9vdGxvYWRlciwgaG93ZXZlciwgaWYgc29tZXRoaW5nIGRpZCBnbyB3cm9uZyB3ZSBuZWVkIHRvIGp1bXAgdG8gdGhlIG90aGVyIGxhYmVsIHdlIGFkZGVkIGBkaXNrUmVhZEZhaWxgLiBUaGlzIHByaW50cyBvdXQgYW4gZXJyb3IgbWVzc2FnZSBhbmQganVtcHMgZW5kbGVzc2x5IHNpbmNlIHdlIGNhbid0IHJlYWxseSBkbyBhbnl0aGluZyBhZnRlciB0aGF0LlxcblxcblNvIG5vdyB3ZSBoYXZlIHRoZSBpbml0aWFsIGJvb3Rsb2FkZXIgYW5kIGNhbiBzdGFydCB3b3JraW5nIG9uIG91ciBzZWNvbmQgYm9vdGxvYWRlci4gVGhpcyB3aWxsIGxvb2sgc2ltaWxhciBiZWNhdXNlIGluaXRpYWxseSB3ZSBqdXN0IHdhbnQgdG8gcHJpbnQgYSBzaW1wbGUgbWVzc2FnZSB0byB2ZXJpZnkgdGhhdCBpdCB3b3JrZWQgY29ycmVjdGx5LlxcblxcbmBgYFxcbltiaXRzIDE2XVxcbltvcmcgMHg5MDAwXVxcblxcbjsgU3RvcmUgdGhlIGJvb3QgZHJpdmVcXG5tb3YgW0JPT1RfRFJJVkVdLCBkbFxcblxcbjsgTG9hZCBhIG1lc3NhZ2UgYW5kIHByaW50XFxubW92IHNpLCBTRUNPTkRfQk9PVF9NU0dcXG5jYWxsIHByaW50U3RyaW5nXzE2XFxuXFxuam1wICRcXG5cXG47IEluY2x1ZGVzXFxuJWluY2x1ZGUgXFxcInByaW50U3RyaW5nXzE2LmFzbVxcXCJcXG5cXG5CT09UX0RSSVZFOiBkYiAwXFxuU0VDT05EX0JPT1RfTVNHOiBkYiBcXFwiVGhlIHNlY29uZCBib290bG9hZGVyIGhhcyBiZWVuIGxvYWRlZCFcXFwiLCAwXFxuYGBgXFxuXFxuV2UgYXJlIG9mZmljaWFsbHkgcHJlcGFyZWQgdG8gc3RhcnQgY29tcGlsaW5nIGFuZCBsb2FkaW5nIHRoZSBmaWxlcyBvbnRvIGFuIGltZyBmaWxlLiBGb3Igb25lIG1vbWVudCB3ZSBuZWVkIHRvIHNoaWZ0IGdlYXJzIGludG8gd3JpdGluZyBhIHByb2dyYW0gdG8gd3JpdGUgb3VyIGJpbmFyeSBmaWxlcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbiB0byB0aGUgaW1nIGZpbGUuIFRoaXMgY2FuIGJlIGRvbmUgaG93ZXZlciB5b3Ugd2FudCBidXQgSSdtIGdvaW5nIHRvIHdyaXRlIGEgcHJvZ3JhbSBpbiBjcHAgdGhhdCB3aWxsIHdvcmsgZm9yIGJvdGggd2luZG93cyBhbmQgdW5peC4gTm8gbWF0dGVyIGhvdyB5b3UgZG8gaXQgdGhlIGJpZyB0aGluZyB0byBrZWVwIGluIG1pbmQgaXMgd2UgbmVlZCB0byBzcGVjaWZ5IHRoZSBvcmRlciBhbmQgbG9jYXRpb24gb2YgdGhlIGZpbGVzLiBUaGUgYm9vdGxvYWRlciBNVVNUIGdvIGZpcnN0IGFuZCBiZSBleGFjdGx5IDUxMiBieXRlcy4gVGhlIHNlY29uZCBib290bG9hZGVyIGNhbiBiZSB3aGVyZXZlciB5b3Ugd2FudCBidXQgeW91IHdpbGwgbmVlZCB0byB0ZWxsIHRoZSBib290bG9hZGVyIHdoZXJlIGl0IG5lZWRzIHRvIGxvYWQgZnJvbS5cXG5cXG5gYGBjcHBcXG4jaW5jbHVkZSA8YXJyYXk+XFxuI2luY2x1ZGUgPHN0cmluZz5cXG4jaW5jbHVkZSA8aW9zdHJlYW0+XFxuI2luY2x1ZGUgPGZzdHJlYW0+XFxuI2luY2x1ZGUgPGZpbGVzeXN0ZW0+XFxuXFxuLy8gRGVmaW5lIGFsbCB0aGUgbmVlZGVkIGZpbGVzIGhlcmUgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcXG5zdGQ6OmFycmF5PHN0ZDo6c3RyaW5nLCAyPiB3cml0ZU9yZGVyID0geyBcXFwiYm9vdGxvYWRlci5hc21cXFwiLCBcXFwic2Vjb25kYm9vdC5hc21cXFwiIH07XFxuXFxuaW50IG1haW4oaW50IGFyZ2MsIGNoYXIqIGFyZ3ZbXSkge1xcbiAgICAvLyBDcmVhdGUgb3Igb3BlbiB0aGUgaW1nIGZpbGVcXG4gICAgc3RkOjpvZnN0cmVhbSBpbWdGaWxlKFxcXCJvcy5pbWdcXFwiLCBzdGQ6Omlvczo6YmluYXJ5KTtcXG5cXG4gICAgYm9vbCBmb3VuZCA9IGZhbHNlO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IHdyaXRlT3JkZXIuc2l6ZSgpOyBpKysgKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IGF1dG8mIGVudHJ5IDogc3RkOjpmaWxlc3lzdGVtOjpkaXJlY3RvcnlfaXRlcmF0b3IoXFxcIi5cXFwiKSkge1xcbiAgICAgICAgICAgIGlmIChlbnRyeS5wYXRoKCkuc3RyaW5nKCkuc3Vic3RyKGVudHJ5LnBhdGgoKS5zdHJpbmcuZmluZF9sYXN0X29mKCcvJykgKyAxKSA9PSB3cml0ZU9yZGVyW2ldKSB7XFxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gQ29tcGlsZSB0aGUgZmlsZVxcbiAgICAgICAgICAgICAgICBpbnQgc3ViSW5kZXggPSBlbnRyeS5wYXRoKCkuc3RyaW5nKCkuZmluZF9sYXN0X29mKCcvJykgKyAxO1xcbiAgICAgICAgICAgICAgICBzeXN0ZW0oc3RkOjpzdHJpbmcoXFxcIm5hc20gXFxcIiArIGVudHJ5LnBhdGgoKS5zdHJpbmcoKS5zdWJzdHIoc3ViSW5kZXgpICsgXFxcIiAtZiBiaW4gLW8gXFxcIiArIGVudHJ5LnBhdGgoKS5zdHJpbmcoKS5zdWJzdHIoKShzdWJJbmRleCwgZW50cnkucGF0aCgpLnN0cmluZygpLmxlbmd0aCgpIC0gc3ViSW5kZXggLSA0KSkuY19zdHIoKSk7XFxuXFxuICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb21waWxlZCBwcm9ncmFtIHRvIHRoZSBpbWcgZmlsZVxcbiAgICAgICAgICAgICAgICBzdGQ6Omlmc3RyZWFtIHJmKGVudHJ5LnBhdGgoKSwgc3RkOjppb3M6OmJpbmFyeSk7XFxuXFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChmb3VuZCkgY29udGludWU7XFxuXFxuICAgICAgICBzdGQ6OmNvdXQgPDwgXFxcIk9uZSBvZiB0aGUgcmVxdWlyZWQgZmlsZXMgd2FzIG5vdCBmb3VuZC5cXFxcblxcXCI7XFxuICAgICAgICByZXR1cm4gLTE7XFxuICAgIH1cXG5cXG4gICAgLy8gQ2xvc2UgdGhlIGZpbGVcXG4gICAgaW1nRmlsZS5jbG9zZSgpO1xcblxcbiAgICByZXR1cm4gMDtcXG59XFxuYGBgXFxuXFxuXFxuPCEtLSBcXG5Tbywgd2UgcHJvZ3JhbW1lZCBvdXIgYm9vdGxvYWRlciBpbiB0aGUgbGFzdCBzZWN0aW9uLCBidXQgZm9yIG91ciBuZXcgcGxhbiB3ZSB3aWxsIG5lZWQgdG8gYWRkIG1vcmUgdG8gaXQuIFNpbmNlIHdlJ3ZlIHNlZW4gc29tZSBvZiB0aGlzIGJlZm9yZSBJJ20gZ29pbmcgdG8gYmUgbW9yZSBzcGFyc2Ugd2l0aCB0aGUgY29tbWVudHMuXFxuXFxuYGBgXFxuW2JpdHMgMTZdXFxuW29yZyAweDdjMDBdXFxuXFxuOyBPdXIgY29kZSB3aWxsIGdvIGhlcmVcXG5cXG5tb3YgYnAsIDB4OEZGRlxcdFxcdFxcdDsgU2V0IHRoZSBiYXNlIHBvaW50ZXIgYXQgMHg4RkZGXFxubW92IHNwLCBicFxcdFxcdFxcdFxcdDsgU2V0IHRoZSBzdGFjayBwb2ludGVyIGF0IHRoZSBiYXNlXFxuXFxubW92IHNpLCBNU0dfUkVBTF9NT0RFXFx0OyBNb3ZlIHRoZSBwb2ludGVyIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgdG8gc2lcXG5jYWxsIHByaW50U3RyaW5nXzE2XFx0XFx0OyBDYWxsIHRoZSBwcmludCBzdHJpbmcgZnVuY3Rpb25cXG5cXG5qbXAgJFxcdFxcdFxcdFxcdFxcdDsgRW5kbGVzc2x5IGp1bXAgb24gdGhpcyBsaW5lIG9mIGNvZGVcXG5cXG4tLSBQUklOVCBGVU5DVElPTiBERUZJTkVEIEhFUkUgLS1cXG5cXG5TRUNPTkRCT09UX09GRlNFVDogZXF1IDB4OTAwMFxcbkJPT1RfRFJJVkU6IGRiIDBcXG5cXG5MQkFfU0VDT05EQk9PVDpcXG4gICAgOyBTaXplIG9mIERBUFxcbiAgICBkYiAweDEwXFxuICAgIDsgVW51c2VkXFxuICAgIGRiIDB4MDBcXG4gICAgOyBOdW1iZXIgb2Ygc2VjdG9ycyB0byBiZSByZWFkXFxuICAgIGR3IDB4MDFcXG4gICAgOyBPZmZzZXQgdG8gdGhlIGxvYWRlZCBsb2NhdGlvbiAteDg2IChsaXR0bGUgZW5kaWFuKVxcbiAgICBkdyBTRUNPTkRCT09UX09GRlNFVFxcbiAgICBkdyAweDAwXFxuICAgIDsgQWJzb2x1dGUgbnVtYmVyIG9mIHRoZSBzdGFydCBzZWN0b3IgdG8gYmUgcmVhZFxcbiAgICBkZCAweDAxXFxuICAgIGRkIDB4MDBcXG5cXG5NU0dfUkVBTF9NT0RFOiAgZGIgXFxcIlN0YXJ0aW5nIHVwIGluIDE2LWJpdCBSZWFsIE1vZGUuXFxcIiwgMFxcbkVSUk9SX01TRzogICAgICBkYiBcXFwiRXJyb3IgcmVhZGluZyBmcm9tIGRpc2suXFxcIiwgMFxcblxcbnRpbWVzIDUxMC0oJC0kJCkgZGIgMFxcbmR3IDB4YWE1NVxcbmBgYFxcblxcbkhlcmUgd2UgY2hhbmdlZCBhIGZldyB0aGluZ3MgdGhhdCBhcmUgaW1wb3J0YW50LiBGaXJzdCwgd2UgY2hhbmdlZCB0aGUgc3RhY2sgbG9jYXRpb24gdG8gMHg4RkZGIHNvIHRoYXQgaXQgd291bGRuJ3Qgc3RhcnQgb24gdGhlIGZpcnN0IGJ5dGUgb2Ygb3VyIHNlY29uZCBzdGFnZSBib290bG9hZGVyLiBTZWNvbmQsIHdlIGRlZmluZWQgdHdvIGRpcmVjdGl2ZXMgY2FsbGVkIEJPT1RfRFJJVkUgYW5kIFNFQ09OREJPT1RfT0ZGU0VULiBCT09UX0RSSVZFIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IG91ciBib290IGRpc2sgdGhhdCB3ZSB3aWxsIG5lZWQgdG8gb3VyIHNlY29uZCBib290bG9hZGVyLiBTRUNPTkRCT09UX09GRlNFVCB3aWxsIGRlZmluZSB0aGUgbG9jYXRpb24gd2hlcmUgd2Ugd2FudCB0byBsb2FkIHRoZSBzZWNvbmQgYm9vdGxvYWRlciBpbiBtZW1vcnkuIE1lbW9yeSBsb2NhdGlvbiAweDkwMDAgd2lsbCBnaXZlIHVzIG11Y2ggbW9yZSBtZW1vcnkgZm9yIHRoZSBib290bG9hZGVyIGFuZCB3b3JrcyBhcyBsb25nIGFzIHdlIGRvIG5vdCBwYXNzIG1lbW9yeSBsb2NhdGlvbiAweDdGRkZGLlxcblxcblRoZSBMaW5lYXIgQmxvY2sgQWRkcmVzcyAoTEJBKSBpcyBhIG5pY2Ugd2F5IG9mIGFjY2Vzc2luZyBhcmVhcyBvbiBvdXIgaGFyZCBkcml2ZS4gSXQgc3RyaXBzIGF3YXkgdGhlIG5lZWQgdG8gc3BlY2lmeSB0aGUgaGVhZCBhbmQgdHJhY2sgd2hlbiBhY2Nlc3NpbmcgYSBtZW1vcnkgYWRkcmVzcyBhbmQgYXNzdW1lcyB3ZSBoYXZlIDUxMiBieXRlIHNlY3RvcnMuIEV2ZW4gaWYgeW91IGRvbid0IGhhdmUgNTEyIGJ5dGUgc2VjdG9ycyBvbiB5b3VyIGRyaXZlIHRoZSBCSU9TIGFuZCBkaXNrIGhhcmR3YXJlIHNob3VsZCBlbXVsYXRlIGl0IGZvciB5b3UuXFxuXFxuSG9wZWZ1bGx5IHlvdSByZWNvZ25pemUgdGhlIGFzc2VtYmx5IGluc3RydWN0aW9ucyB3ZSB1c2VkIGZvciB0aGlzIHN0cnVjdHVyZSwgaWYgbm90IHRoZSBzaW1wbGUgcnVuZG93biBpcyBkYiBpcyBkZWNsYXJlIGJ5dGUsIGR3IGlzIGRlY2xhcmUgd29yZCwgYW5kIGRkIGlzIGRlY2xhcmUgZG91YmxlIHdvcmQuIFdlIHN0YXJ0IGJ5IGRlZmluaW5nIHRoZSBEaXNrIEFkZHJlc3MgUGFja2V0IChEQVApIHdoaWNoIHdpbGwgbWFrZSBsb2FkaW5nIHRoYXQgbXVjaCBlYXNpZXIuIFRoZSBkZWZpbml0aW9uIGlzIGFzIGZvbGxvd3M6XFxuXFxuMSBieXRlIC0gU2l6ZSBvZiB0aGUgcGFja2V0IChBbHdheXMgc2V0IHRvIDB4MTApXFxuXFxuMSBieXRlIC0gVW51c2VkIChTZXQgdGhpcyB0byAweDAwKVxcblxcbjIgYnl0ZXMgLSBUaGUgbnVtYmVyIG9mIHNlY3RvcnMgdG8gcmVhZCBmcm9tIHRoZSBoYXJkIGRyaXZlXFxuXFxuNCBieXRlcyAtIFRoZSBzZWdtZW50Om9mZnNldCBwb2ludGVyIHRvIG1lbW9yeSBidWZmZXJcXG5cXG44IGJ5dGVzIC0gVGhlIGFic29sdXRlIG51bWJlciBvZiB0aGUgc3RhcnQgc2VjdG9yIHRvIHJlYWQgZnJvbVxcblxcbj4gIyMgRXh0cmFcXG4+IFRoZXJlIGlzIGFsc28gYW5vdGhlciB3YXkgdG8gYWRkcmVzcyBtZW1vcnkgb24gYSBoYXJkIGRpc2sgY2FsbGVkIEN5bGluZGVyIEhlYWQgU2VjdG9yIChDSFMpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG9sZGVyIGRldmljZXMgbGlrZSBmbG9wcHkgZGlza3MgdGhhdCBoYXZlIG5vIGRpcmVjdCB3YXkgb2YgYmVpbmcgYWNjZXNzZWQgd2l0aCBMQkEncy4gTHVja2lseSB0aGUgbmFtZSBpcyBwcmV0dHkgc2VsZi1leHBsYW5pdG9yeSwgd2UganVzdCBuZWVkIHRvIHNwZWNpZnkgdGhlIGN5bGluZGVyLCB0aGUgaGVhZCwgYW5kIHRoZSBzZWN0b3IuIEJJT1Mgd2lsbCBmaW5kIHRoaXMgbG9jYXRpb24gZm9yIHVzIG9uIHRoZSBoYXJkIGRyaXZlIGFuZCB3ZSBjYW4gdGhlbiByZWFkIG9yIHdyaXRlIGZyb20gdGhhdCBsb2NhdGlvbiBhcyB3ZSB3aXNoLlxcblxcbldlIHdpbGwgc2VlIGhvdyB0aGlzIGlzIHVzZWQgd2hlbiB3ZSBjYWxsIHRoZSBpbnRlcnJ1cHQgaXRzZWxmLiBUbyBzYXZlIHNwYWNlIEkgd29uJ3Qgc2hvdyB0aGUgZW50aXJlIGZpbGUgYWxsIHRoZSB0aW1lIGJ1dCBJIHdpbGwgdHJ5IGFuZCBkZWZpbmUgc29tZXRoaW5nIHRoYXQgd2FzIHByZXZpb3VzbHkgZGVmaW5lZCBzbyB5b3Uga25vdyB3aGVyZSB0byBzdGFydCBhbmQgZW5kLiBUaGVzZSBhZGRpdGlvbnMgd2lsbCBiZSBhIGdyZWF0IGJhc2UgZm9yIHRoZSByZXN0IG9mIG91ciBwcm9ncmFtLlxcblxcbiMjIyMgTG9hZGluZyBGaWxlc1xcblxcbmBgYFxcbjsgU3RvcmUgdGhlIGJvb3QgbG9jYXRpb24gaW50byBCT09UX0RSSVZFXFxubW92IFtCT09UX0RSSVZFXSwgZGxcXG5cXG47IFNldCB1cCB0aGUgc3RhY2sgbG9jYXRpb24gYXQgMHg4RkZGXFxubW92IGJwLCAweDhGRkYgIDsgU2V0IHRoZSBiYXNlIHN0YWNrIHBvaW50ZXJcXG5tb3Ygc3AsIGJwICAgICAgOyBTZXQgdGhlIHN0YWNrIHBvaW50ZXJcXG5cXG5tb3Ygc2ksIE1TR19SRUFMX01PREVcXG5jYWxsIHByaW50U3RyaW5nXzE2XFxuXFxubG9hZFNlY29uZEJvb3Q6XFxuICAgIDsgU0kgLSBvZmZzZXQgdG8gdGhlIGRpc2sgYWRkcmVzcyBwYWNrZXRcXG4gICAgbW92IHNpLCBMQkFfU0VDT05EQk9PVFxcbiAgICA7IEFIIC0gVGhlIHN1YnJvdXRpbmUgZm9yIDB4MTMgLSBFeHRlbmRlZCByZWFkIGZyb20gZGlza1xcbiAgICBtb3YgYWgsIDB4NDJcXG4gICAgOyBETCAtIEJvb3QgZHJpdmVcXG4gICAgbW92IGRsLCBbQk9PVF9EUklWRV1cXG5cXG4gICAgOyBJbnRlcnJ1cHRcXG4gICAgaW50IDB4MTNcXG4gICAgamMgZGlza1JlYWRGYWlsZWRcXG5cXG4gICAgam1wIFNFQ09OREJPT1RfT0ZGU0VUXFxuXFxuZGlza1JlYWRGYWlsZWQ6XFxuICAgIG1vdiBzaSwgRVJST1JfTVNHXFxuICAgIGNhbGwgcHJpbnRTdHJpbmdfMTZcXG4gICAgam1wICRcXG5cXG4tLSBQUklOVCBGVU5DVElPTiBERUZJTkVEIEhFUkUgLS1cXG5cXG5gYGBcXG5cXG5BIHF1aWNrIG5vdGUgYmVmb3JlIHdlIGdldCBpbnRvIHRoZSBidWxrIG9mIHRoZSBhZGRpdGlvbi4gQXQgdGhlIGJlZ2lubmluZyBvZiBvdXIgYm9vdGxvYWRlciB3ZSBoYXZlIG5vdyBhZGRlZCBhbiBpbnN0cnVjdGlvbiB0byBzdG9yZSB0aGUgYm9vdCBkcml2ZSBpbiBhIHZhcmlhYmxlLiBXaGVuZXZlciB3ZSBzdGFydCB1cCBvdXIgY29tcHV0ZXIgdGhlIGRyaXZlIHRoYXQgd2UgbG9hZGVkIHRoZSBib290bG9hZGVyIGZyb20gd2lsbCBoYXZlIGl0J3MgaWQgc3RvcmVkIGluIHRoZSBkbCByZWdpc3Rlci4gV2UgbmVlZCB0byBzYXZlIHRoaXMgZm9yIGxhdGVyLlxcblxcbk5vdyB3ZSBoYXZlIGFkZGVkIHRoZSBhY3R1YWwgZnVuY3Rpb25hbGl0eSB0aGF0IHdpbGwgYWxsb3cgdXMgdG8gbG9hZCBvdXIgc2Vjb25kIGJvb3Rsb2FkZXIgZnJvbSB0aGUgZGlzay4gV2UgYWRkZWQgdGhlIGxhYmVscyBgbG9hZFNlY29uZEJvb3RgIGFuZCBgZGlza1JlYWRGYWlsZWRgIHRvIGhlbHAgdXMgb3JnYW5pemUgb3VyIHByb2dyYW0uIEluIGNhc2UgeW91IGFyZSB1bmF3YXJlIHRoZSBgbG9hZFNlY29uZEJvb3Q6YCBpcyBhIGxhYmVsLiBUaGlzIGFsbG93cyB1cyB0byBkZWZpbmUgY2VydGFpbiBsb2NhdGlvbnMgaW4gbWVtb3J5IGFsbW9zdCBsaWtlIGZ1bmN0aW9ucyBpbiBjIG9yIGMrKy4gVGhpcyB3b24ndCBhY3R1YWxseSBiZSBhZGRlZCBpbnRvIG91ciBwcm9ncmFtIGJ1dCB3aWxsIGFsbG93IHRoZSBhc3NlbWJsZXIgdG8gcmVwbGFjZSBhbnkgb2NjdXJhbmNlcyBvZiB0aGlzIGxhYmVsIHdpdGggdGhlIGNvcnJlY3QgbG9jYXRpb24gaW4gbWVtb3J5LiBTbyBpZiB3ZSB3cm90ZSBgam1wIGxvYWRTZWNvbmRCb290YCB0aGUgcHJvZ3JhbSB3b3VsZCByZXBsYWNlIGxvYWRTZWNvbmRCb290IHdpdGggdGhlIGxvY2F0aW9uIGluIG1lbW9yeSB3aGVyZSB0aGUgbGFiZWwgaXMgZGVmaW5lZCBhbmQganVtcCB0byB0aGF0IGxvY2F0aW9uIHdoZXJlIGl0IHdpbGwgY29udGludWUgdG8gZXhlY3V0ZSBpbnN0cnVjdGlvbnMuIEZpcnN0IHdlIHdpbGwgZ28gb3ZlciB0aGUgbG9hZFNlY29uZEJvb3QgbGFiZWwuXFxuXFxuVGhlIGZpcnN0IGluc3RydWN0aW9uIHVuZGVyIHRoZSBgbG9hZFNlY29uZEJvb3RgIGxhYmVsIGlzIHdoZXJlIHdlIGdldCB0byBzZXQgdXAgdGhlIExCQV9TRUNPTkRCT09UIHN0cnVjdHVyZSBiZWZvcmUgd2UgdXNlIGl0LiBUaGlzIHdpbGwgYmUgY3J1Y2lhbCBpbiB0ZWxsaW5nIHRoZSBCSU9TIHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBtZW1vcnkgd2Ugd2FudC4gUmVtZW1iZXIgdGhhdCB0aGUgTEJBIHN0cnVjdHVyZSBob2xkcyB0aGUgc3RhcnRpbmcgc2VjdG9yIG9mIG91ciBkYXRhLCB0aGUgc2l6ZSBvZiB0aGUgZGF0YSwgYW5kIHRoZSBsb2NhdGlvbiB3aGVyZSB3ZSB3YW50IHRvIGxvYWQgaXQgaW50byBSQU0uIE5leHQgd2UgbG9hZCB0aGUgc3Vicm91dGluZSAweDEzIGludG8gdGhlIHJlZ2lzdGVyIGFoIGxpa2Ugd2UgZGlkIGJlZm9yZSB3aXRoIHRoZSBwcmludCBpbnRlcnJ1cHQuIE5vdyBpcyB3aGVyZSB3ZSB1c2UgdGhlIEJPT1RfRFJJVkUgd2Ugd2VyZSBzYXZpbmcgZWFybGllci4gVGhpcyB3aWxsIHRlbGwgdGhlIEJJT1Mgd2hhdCBkZXZpY2Ugd2Ugd2FudCB0byBzZWFyY2ggZm9yIHRoZSBtZW1vcnkgb24uIE5leHQgd2UgYWN0dWFsbHkgY2FsbCB0aGUgaW50ZXJydXB0IHRvIGxvYWQgdGhlIGZpbGUgYW5kIGp1bXAgdG8gYGRpc2tSZWFkRmFpbGVkYCBpZiB0aGUgY2FycnkgZmxhZyBpcyBzZXQuIEJ5IGxvb2tpbmcgYXQgdGhlIGludGVycnVwdHMgZG9jdW1lbnRhdGlvbiB3ZSBrbm93IHRoYXQgaWYgYW55dGhpbmcgd2VudCB3cm9uZyB3aGlsZSB0cnlpbmcgdG8gcmVhZCBmcm9tIHRoZSBkaXNrIGl0IHdvdWxkIHNldCB0aGlzIGZsYWcgdG8gbGV0IHVzIGtub3cuIEZpbmFsbHkgaWYgYWxsIGlzIHdlbGwgd2UganVtcCB0byB0aGUgbWVtb3J5IGxvY2F0aW9uIHdoZXJlIHdlIGxvYWRlZCBvdXIgc2Vjb25kIGJvb3Rsb2FkZXIuXFxuXFxuVGhlIHNlY29uZCBsYWJlbCBkZWZpbmVzIGEgc2hvcnQgc2V0IG9mIGluc3RydWN0aW9ucyB0aGF0IGhhbmRsZXMgZXJyb3JzIHRoYXQgbWF5IG9jY3VyIHdoaWxlIHRyeWluZyB0byByZWFkIHRoZSBkaXNrLiBUaGlzIGlzIHRoZSBleGFjdCBzYW1lIGFzIHRoZSBpbnN0cnVjdGlvbnMgd2UgdXNlZCB0byBwcmludCBvdXIgZmlyc3QgbWVzc2FnZSwgb25seSB0aGlzIHRpbWUgd2Ugd2lsbCBwcmludCBhbiBlcnJvciBtZXNzYWdlLlxcblxcbkFtYXppbmdseSB0aGF0IGlzIGFsbCB3ZSBuZWVkIHRvIGxvYWQgYSBjaHVuayBvZiBtZW1vcnkgZnJvbSB0aGUgZGlzayBvbnRvIFJBTS4gTm93IGl0IGlzIHRpbWUgdG8gd3JpdGUgdGhlIHNlY29uZCBib290bG9hZGVyLiBGb3IgdGhpcyB3ZSB3aWxsIGp1c3QgbWFrZSBhIHN1cGVyIHNpbXBsZSBib290bG9hZGVyIHRoYXQgcHJpbnRzIGEgc21hbGwgbWVzc2FnZS4gV2UndmUgc2VlbiBob3cgdG8gZG8gdGhpcyBiZWZvcmUgYnV0IEknbGwgcHV0IGl0IGJlbG93IGJlY2F1c2UgSSBwbGFuIG9uIGNoYW5naW5nIGEgZmV3IHRoaW5ncy5cXG5cXG5gYGBcXG5bYml0cyAxNl1cXG5bb3JnIDB4OTAwMF1cXG5cXG47IFN0b3JlIHRoZSBib290IGRyaXZlXFxubW92IFtCT09UX0RSSVZFXSwgZGxcXG5cXG5tb3Ygc2ksIE1TR19TRUNPTkRfQk9PVCAgICAgOyBNb3ZlIHRoZSBwb2ludGVyIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgdG8gc2lcXG5jYWxsIHByaW50U3RyaW5nXzE2ICAgICAgICAgOyBDYWxsIHRoZSBwcmludCBzdHJpbmcgZnVuY3Rpb25cXG5cXG5qbXAgJCAgICAgICAgICAgICAgICAgICAgICAgOyBFbmRsZXNzbHkganVtcCBvbiB0aGlzIGxpbmVcXG5cXG4laW5jbHVkZSBcXFwicHJpbnRGdW5jdGlvbnMvcHJpbnRTdHJpbmcxNi5hc21cXFwiXFxuXFxuQk9PVF9EUklWRTogZGIgMFxcbk1TR19TRUNPTkRfQk9PVDogXFxcIkxvYWRlZCB0aGUgc2Vjb25kIGJvb3Rsb2FkZXJcXFwiLCAwXFxuYGBgXFxuXFxuSGVyZSB3ZSBoYXZlIGEgdmVyeSBzaW1pbGFyIGJvb3Rsb2FkZXIgdG8gd2hhdCB3ZSBoYWQgb3JpZ2luYWxseSBcXG5cXG4jIyMjIENvbmNsdXNpb25cXG5cXG5cXG5bUmV0dXJuIHRvIHRoZSBQb3N0cyBQYWdlXShodHRwczovL2FkaXNvbnloZWF0aGNvdHQuZ2l0aHViLmlvL2FkaXNvbl9oZWF0aGNvdHQvcG9zdHMpIC0tPlwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./content/osdev-bootloader.md\n");

/***/ })

})