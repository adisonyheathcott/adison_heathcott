<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1"/><meta charSet="utf-8"/><meta name="Description" content="Adison Heathcott&#x27;s main page."/><title>Adison Heathcott</title><meta name="next-head-count" content="4"/><link rel="preload" href="/adison_heathcott/_next/static/css/9282e2def12de35ca96c.css" as="style"/><link rel="stylesheet" href="/adison_heathcott/_next/static/css/9282e2def12de35ca96c.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/adison_heathcott/_next/static/chunks/main-d05829dd66b3e1d8dba3.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/webpack-f9942f282841fa8e3981.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/framework.0c239260661ae1d12aa2.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/a9a7754c.3e676eb972e02f9f394c.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/cb1608f2.3eb57f0c33083404a117.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/b390309770db065fb8b440ac7fc4a6de136d7abc.88a98345373b768921d7.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/b55bc555eab864841adf6c3eb09476da0ca9cc92.430f01b3a08741c3f584.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/pages/_app-1988fd1f277b02054148.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/9f96d65d.1ff5480bc23bdbbc81ff.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/62bb8ee6c2f5191f1fc2bff08a7b84d038648b6c.4314cb0a9e66a7677577.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/c2b541414cb101b874f2f4dc935956aab3eab2d0.3eef0c55f6208d925fd3.js" as="script"/><link rel="preload" href="/adison_heathcott/_next/static/chunks/pages/posts-12ed76fe0122e5f554b0.js" as="script"/></head><body><div id="__next"><div id="posts-div"><div id="posts-div-top"><button><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="home" class="svg-inline--fa fa-home fa-w-18 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512" id="home-icon"><path fill="currentColor" d="M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"></path></svg></button><h3>POSTS</h3></div><div id="post-categories-div"><ul><li id="cat-li"><button id="cat-li-button"><p>Operating System Development</p><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="caret-down" class="svg-inline--fa fa-caret-down fa-w-10 fa-2x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512" id="down-icon"><path fill="currentColor" d="M31.3 192h257.3c17.8 0 26.7 21.5 14.1 34.1L174.1 354.8c-7.8 7.8-20.5 7.8-28.3 0L17.2 226.1C4.6 213.5 13.5 192 31.3 192z"></path></svg></button><ul id="cat-ul"><li id="cat-li-li"><button id="cat-li-li-button">OS Dev Bootloader</button></li><li id="cat-li-li"><button id="cat-li-li-button">OS Dev Introduction</button></li></ul></li></ul></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"title":"Adison Heathcott","description":"Adison Heathcott's main page.","cats":["Operating System Development"],"files":[["---\nslug: osdev-bootloader\ntitle: OS Dev Bootloader\ndescription: Learning about the bootloader and some common utilities.\nid: Operating System Development\ndate: 04-10-2021\n---\n\n---\n\n![Alt Text](https://images.unsplash.com/photo-1537498425277-c283d32ef9db?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D\u0026ixlib=rb-1.2.1\u0026auto=format\u0026fit=crop\u0026w=1057\u0026q=80)\n\n###### Photo by [Tianyi Ma](\"https://unsplash.com/@tma?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\") on [Unsplash](\"https://unsplash.com/s/photos/computer?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText\")\n\n#### Preface\n\nAs we saw in the last section the bootloader can do some interesting things. So far all we've done is display a simple message when we start up the emulator. We could do a lot more to it with interrupts and some assembly skills but stop and think for a minute, what can we really do with 512 bytes of memory. It's not a terribly small amount of space but it's definitely too small to do anything interesting or complicated like video memory, drivers, or anything else. What's the solution? A common practice is to use this space to jump start a second stage bootloader that will be much bigger than this. We are still restricted by memory that is already taken by BIOS and the maximum accessible memory caused by the CPU's 16-bit mode but it is going to be much more memory than we had before. So that's what we are going to do, load a second stage bootloader at memory location 0x9000 and jump to it from the intial bootloader. With a plan in mind let's move forward.\n\n#### Setting Up\n\nSo, before we start programming we need to go over some things we will use. The first of which is how to access hard drive sectors using Linear Block Addressing. \n\nThe Linear Block Address (LBA) is a nice way of accessing areas on our hard drive. It strips away the need to specify the head and track when accessing a memory address and allows us to access more memory than we could before. One thing to note is it automatically assumes that we have 512 byte sectors. Even if you don't have 512 byte sectors on your drive the BIOS and disk hardware should emulate it for you. The LBA structure is as follows:\n\n| Offset Range | Size | Description |\n| - | - | - |\n| 0x00 | 1 byte | Size of the Data Address Packet (Usually 0x10) |\n| 0x01 | 1 byte | Unused (Usually 0x00) |\n| 0x02 - 0x03 | 2 bytes | Number of sectors to be read from the hard disk |\n| 0x04 - 0x07 | 4 bytes | Segment:Offset pointer to the sector that contains the data we want to load |\n| 0x08 - 0x0F | 8 bytes | Absolute number of the starting sector to be read (1st sector is 0) |\n\n\u0026nbsp;\n\n\u003e ## Extra\n\u003e There is also another way to address memory on a hard disk called Cylinder Head Sector (CHS). This is particularly useful for older devices like floppy disks that have no direct way of being accessed with LBA's. Luckily the name is pretty self-explanitory, we just need to specify the cylinder, the head, and the sector. BIOS will find this location for us on the hard drive and we can then read or write from that location as we wish.\n\n#### Loading From Memory\n\nLet's start by defining the variables we will need to load memory in our first bootloader. This will be an addition to what we had, however, I will also be changing a few things. If you added your own code I advise moving it to the second bootloader so we can safely stay under the 512 byte limit. What we are adding isn't that big but it's better to be safe than run over the memory limit unknowingly.\n\n```\n[bits 16]\n[org 0x7c00]\n\nmov [BOOT_DRIVE], dl\n\nmov bp, 0x8FFF\nmov sp, bp\n\nmov si, MSG_REAL_MODE\ncall printString_16\n\njmp $\n\n%include \"printString_16.asm\"\n\nSECONDBOOT_OFFSET: equ 0x9000\nBOOT_DRIVE: db 0\n\nLBA_SECONDBOOT:\n    ; Size of DAP\n    db 0x10\n    ; Unused\n    db 0x00\n    ; Number of sectors to be read\n    dw 0x01\n    ; Offset to the loaded location -x86 (little endian)\n    dw SECONDBOOT_OFFSET\n    dw 0x00\n    ; Absolute number of the start sector to be read\n    dd 0x01\n    dd 0x00\n\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\nERROR_MSG: db \"Error reading from disk.\", 0\n\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nHere we've added and changed a few things. Firstly we recorded what drive our bootloader started up on. This is automatically stored in the register dl when the computer is booted. Later on we will need to know this so we can load the correct information from the correct drive. Second we changed the stack location to 0x8FFF so the first byte of our stack does not overwrite the first byte of our next bootloader. Then we find something new `%include \"printFunctions/printString_16.asm`. This is similar to any higher level language include and just copies that code at the location of the include. This will allow us to stop duplicating code and to make our files easier to read. If it wasn't clear you should now move the code for printing in 16 bit mode into it's own file named \"printString_16.asm\".\n\nNext we need to set up our code to actually tell the CPU to load the second bootloader into memory.\n\n```\n[bits 16]\n[org 0x7c00]\n\nmov [BOOT_DRIVE], dl\n\nmov bp, 0x8FFF\nmov sp, bp\n\nmov si, MSG_REAL_MODE\ncall printString_16\n\nloadSecondBoot:\n    ; SI - offset to the disk address packet\n    mov si, LBA_SECONDBOOT\n    ; AH - The subroutine for 0x13 - Extended read from disk\n    mov ah, 0x42\n    ; DL - Boot drive\n    mov dl, [BOOT_DRIVE]\n\n    ; Interrupt\n    int 0x13\n    jc diskReadFailed\n\n    jmp SECONDBOOT_OFFSET\n\ndiskReadFailed:\n    mov si, ERROR_MSG\n    call printString_16\n    jmp $\n\n%include \"printString_16.asm\"\n\nSECONDBOOT_OFFSET: equ 0x9000\nBOOT_DRIVE: db 0\n\nLBA_SECONDBOOT:\n    ; Size of DAP\n    db 0x10\n    ; Unused\n    db 0x00\n    ; Number of sectors to be read\n    dw 0x01\n    ; Offset to the loaded location -x86 (little endian)\n    dw SECONDBOOT_OFFSET\n    dw 0x00\n    ; Absolute number of the start sector to be read\n    dd 0x01\n    dd 0x00\n\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\nERROR_MSG: db \"Error reading from disk.\", 0\n\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nWhat we added isn't that much but it gets us where we need to be. The first large addition is the `loadSecondBoot` label which loads the LBA info into SI, subroutine subfunction in AH, and the boot drive in DL. We then call the extended read from disk interrupt and check if anything went wrong by checking the carry bit. If nothing went wrong we jump to the beginning of the second bootloader, however, if something did go wrong we need to jump to the other label we added `diskReadFail`. This prints out an error message and jumps endlessly since we can't really do anything after that.\n\nSo now we have the initial bootloader and can start working on our second bootloader. This will look similar because initially we just want to print a simple message to verify that it worked correctly.\n\n```\n[bits 16]\n[org 0x9000]\n\n; Store the boot drive\nmov [BOOT_DRIVE], dl\n\n; Load a message and print\nmov si, SECOND_BOOT_MSG\ncall printString_16\n\njmp $\n\n; Includes\n%include \"printString_16.asm\"\n\nBOOT_DRIVE: db 0\nSECOND_BOOT_MSG: db \"The second bootloader has been loaded!\", 0\n```\n\nWe are officially prepared to start compiling and loading the files onto an img file. For one moment we need to shift gears into writing a program to write our binary files in the correct location to the img file. This can be done however you want but I'm going to write a program in cpp that will work for both windows and unix. No matter how you do it the big thing to keep in mind is we need to specify the order and location of the files. The bootloader MUST go first and be exactly 512 bytes. The second bootloader can be wherever you want but you will need to tell the bootloader where it needs to load from.\n\n```cpp\n#include \u003carray\u003e\n#include \u003cstring\u003e\n#include \u003ciostream\u003e\n#include \u003cfstream\u003e\n#include \u003cfilesystem\u003e\n\n// Define all the needed files here in the correct order\nstd::array\u003cstd::string, 2\u003e writeOrder = { \"bootloader.asm\", \"secondboot.asm\" };\n\nint main(int argc, char* argv[]) {\n    // Create or open the img file\n    std::ofstream imgFile(\"os.img\", std::ios::binary);\n\n    bool found = false;\n    for (int i = 0; i \u003c writeOrder.size(); i++ ) {\n        for (const auto\u0026 entry : std::filesystem::directory_iterator(\".\")) {\n            if (entry.path().string().substr(entry.path().string.find_last_of('/') + 1) == writeOrder[i]) {\n                found = true;\n\n                // Compile the file\n                int subIndex = entry.path().string().find_last_of('/') + 1;\n                system(std::string(\"nasm \" + entry.path().string().substr(subIndex) + \" -f bin -o \" + entry.path().string().substr()(subIndex, entry.path().string().length() - subIndex - 4)).c_str());\n\n                // Write the compiled program to the img file\n                std::ifstream rf(entry.path().string().substr(0, entry.path().string().find_last_of('.')), std::ios::binary | std::ios::in);\n                if (!rf) { std::cout \u003c\u003c \"Failed to open the file.\\n\"; return -1; }\n                std::copy(std::istreambuf_iterator\u003cchar\u003e(rf), std::istreambuf_iterator\u003cchar\u003e( ), std::ostreambuf_iterator\u003cchar\u003e(imgFile));\n\n                rf.close();\n\n                break;\n            }\n        }\n\n        if (found) continue;\n\n        std::cout \u003c\u003c \"One of the required files was not found.\\n\";\n        return -1;\n    }\n\n    // Close the file\n    imgFile.close();\n\n    return 0;\n}\n```\n\nThis isn't the best way to do it and it can use some error checking but for simplicity sake this will do. Now you can set the writeOrder array to contain your file names in the correct order, compile the program, and run it. You should then be able to run:\n\n```\nqemu-system-x86_64 -drive format=raw,file=os.img\n```\n\nor if you're on windows:\n\n```\nqemu-system-x86_64 -L C:/Progra~1/qemu -drive format=raw,file=os.img\n```\n\nQemu should open up and you should see your two messages \"Starting up in 16-bit Real Mode.\" and \"The second bootloader has been loaded!\". If you see an error about no bootable devices check that you are correctly writing the **binary data** to the img file.\n\n#### Conclusion\n\nNow we can add more code to our bootloader without worrying about the memory limit. It may seem like we aren't doing much with each addition but we are building up a strong base for adding some cool things in the future. As always take some time to mess around and see what you can do. The next topic we are going to cover is going into 32-bit protected mode and loading the kernel. It will be the most complicated thing we have done so far but it will be worth it. So be sure you are comfortable with the basics. As always if anything was confusing I suggest you research it some more as it might be imporant to understand later.\n\n\n[Return to the Posts Page](https://adisonyheathcott.github.io/adison_heathcott/posts)","---\nslug: osdev-intro\ntitle: OS Dev Introduction\ndescription: An introduction into operating system development.\nid: Operating System Development\ndate: 02-14-2021\n---\n\n---\n\n![Alt Text](https://images.unsplash.com/photo-1484417894907-623942c8ee29?ixlib=rb-1.2.1\u0026ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D\u0026auto=format\u0026fit=crop\u0026w=1189\u0026q=80)\n\n###### Photo by [Emile Perron](https://unsplash.com/@emilep?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/programming?utm_source=unsplash\u0026amp;utm_medium=referral\u0026amp;utm_content=creditCopyText)\n\n#### Preface\n\nBefore I begin there are some things that need to be addressed. Firstly, I am only a hobbyist not a professional. I do my best to make sure my information is correct and easy to understand, however, there are a million ways to do everything. My way is not the end all way and is certainly not the best way. \n\nSecondly, this series is meant to help the reader understand the workings of an operating system and how it's written, not show them the best way to implement one. Although I want to keep the information simple, I understand some people have an unquenchable thirst for knowledge so I will add additional interesting information wherever possible. \n\nLastly, in this series I will be using x86 assembly Intel syntax for the entire codebase so you will either need to review that before starting or learn it as you go. I'll keep the code as simple as possible so if you are only here for theory you only need to know a small amount of assembly. \n\nWith that being said, let's move forward.\n\n#### Setup\n\nBefore we can start going over anything, we need to set up [QEMU]( https://www.qemu.org/), [NASM]( https://www.nasm.us/), and any text editor of your choice (Personally I use [VSCode]( https://code.visualstudio.com/)). [QEMU]( https://www.qemu.org/) will be our machine emulator so that we can test our code in the correct environment and [NASM]( https://www.nasm.us/) will compile our assembly programs into their respective binary files.\n\n[QEMU]( https://www.qemu.org/) is super easy to download and install. Just be sure to pay attention to where it gets downloaded in case something goes wrong and you have to set the environment variable yourself.\n[NASM]( https://www.nasm.us/)  is just as easy and again be sure to pay attention to where it is downloaded.\nNow to make sure both programs are working and the environment variables are set we will run two commands on the command line. (Excluding what is in parenthesis) \n``` \n\u003e nasm\n\tnasm: fatal: no input file specified\n\tType nasm -h for help.\n\u003e qemu-system-x86_64 -L C:/Progra~1/qemu \t(Windows)\n\u003e qemu-system-x86_64\t\t\t\t\t\t(Mac)\n```\n\nAfter running the nasm command you should see the same output. If you do not make sure you installed it correctly and that you have your environment variables set up correctly. \n\nAfter running the qemu command you should see the qemu emulator window open. It will go through its usual process and eventually say \"No bootable device\". This is fine, we will be giving it a bootable device later on. If you do not see this check that it is installed correctly and that you have the correct environment variables set. A note on the additonal \"-L C:/Progra\\~1/qemu\": This is used to tell qemu where to find certain dependencies it needs to run. If this does not work for you try changing \"C:/Progra\\~1/qemu\" to the directory where you installed qemu. If you are on Windows you will most likely need to keep the `-L C:/Progra\\~/qemu`, however, if you are on MAC this will not work so you need to delete that line.\n\nFor the text editor I like to have a syntax highlighter so I use the vscode addon [x86 and x86_64 Assembly](https://marketplace.visualstudio.com/items?itemName=13xforever.language-x86-64-assembly) by 13xforever.\n\n#### Prerequisites\n\nI'm going to assume you already know what an operating system is and know a little about what it does. If you were curious we are going to use legacy BIOS and not UEFI. If you don't know what these are that's fine, we will go over this. Before we start with writing the OS we need to go over some basics.\n\n## Disk Drive\n\n\u003e ## Extra\n\u003e If you own a computer you probably own a hard disk (or SSD if you've moved on or Floppy Disk if you're old) and you may have never thought about what it was. The hard disk is a temporary storage device used for storing things in memory that won't get wiped when you restart your computer. It records data by magnetizing a thin film of ferromagnetic material. Inside the hard drive is a spindle that holds 1 to 5 platters, which are small (10-20nm depth) circular disks, which are covered in the ferromagnetic material on both sides. There is also an arm for each platter on the drive that contains the heads capable of reading and writing data.\n\nFor our project you don't need to know the intracacies of the hard disk but it would be good to know how memory works and how it is arranged. The hard drive separates areas of memory into sectors, clusters, and tracks. Tracks are concentric circles, a 1 bit wide ring, that pass under a single stationary head during a disk rotation. The track is divided into segments of sectors. Sectors are blocks of memory defined in size by the type of hard disk. Most commonly the sector is 512 bytes, however, on CD-ROMs and DVD-ROMs sectors are 2048 bytes and on newer hard drives, Advanced Format disks, they can be 4096 bytes. Clusters are combinations of sectors usually defined in size by the programmer. Clusters come in handy to store files or other large amounts of memory. For a 4TB hard drive instead of keeping track of 8,589,934,592 sectors it would be much easier to define cluster size as 2048 bytes so we only keep track of 2,147,483,648 sectors. The only rule is you must use a number of sectors that is an exponent of 2, so 8 or 16 but never 10 or 5 etc. Most commonly I've seen 4096 byte (4KB) clusters for most file systems.\n\n## CPU and Registers\n\nWhen you hear about the CPU you probably think of the simple explanation everybody gives, “It’s just a small piece of hardware that executes code”. This is true, however, there is so much more behind the CPU than simple instruction execution. It can provide memory protection, multitasking capabilities, code privilege levels, registers, cached memory, and more. If you already know about the specifics of registers, you can skip this section but if you don’t, we need to go over them. They will be vital to programming our operating system.\n\nYou can think of registers as hardware variables. They are small memory locations used for extremely fast memory access, this speed comes from its implementation and location since its so close to the CPU core. They are usually classified by their usage and size, so you’ll hear 32-bit accumulator register, or 64-bit data register. We will go over the usages in just a bit.\n\nFor clarification we will define a byte as 8-bits, a word as 16-bits, a doubleword as 32-bits, a quadword as 64-bits, and a double quadword as 128-bits.\n\nYou will need to know this information as it dictates how to access the registers. Originally on the first 16-bit CPUs we had fourteen 16-bit regsiters.\n\nGeneral Purpose Registers\n- AX - Accumulator Register\n- BX - Base Register\n- CX - Counter Register\n- DX - Data Register\n\nStack Registers\n- BP - Base Stack Pointer Register\n- SP - Stack Pointer Register\n\nAddress Registers\n- SI - Source Index Register\n- DI - Destination Index Register\n- BP and BX (Not new registers but also considered address registers)\n\nSegment Registers\n- CS - Code Segment\n- DS - Data Segment\n- SS - Stack Segment\n- ES - Extra Segment\n\nInstruction Pointer\n- IP\n\nAnd finally the FLAGS register that holds flags such as the carry flag, overflow flag, zero flag, etc. Later on three additional registers were added for special table access GDTR, LDTR, and IDTR and a fourth for task switching TR. The general purpose registers can be accessed differently by exchaning the X with an H (high byte) or L (low byte). For example AX is the 16-bit access, AH is the high byte access, and AL is the low byte access. It would be the same for BX, BH, BL, CX, CH, CL, etc.\n\nThese worked well but it was only a matter of time before something would change, and that change came with the advent of the 32-bit CPU. The 80386 processor brought an extension onto the registers and added two extra segment registers. Before, our general purpose registers were AX, BX, CX, and DX. Now we have **Extended** registers EAX, EBX, ECX, and EDX which can hold 32-bits now instead of 16. Also included were ESI, EDI, EBP, ESP, EFLAGS, and EIP. The two stack registers added were FS and GS. On top of the extended registers, the 32-bit CPU brought some really cool 64-bit MMX registers, but we won't get into that, you can look them up if you're interested.\n\nAgain, these worked well until the advent of the 64-bit CPU. The 64-bit architecture brought extensions to other registers such as RSI, RDI, RBP, RSP, RFLAGS, and RIP. It also brought extensions to the general purpose registers, RAX, RBX, RCX, and RDX, and added eight more general purpose register R8-R15 (All registers with R-prefix are 64-bits). Since the new registers were named R# instead of a legacy name they have a different method of access. R8 (qword), R8D (lowest double word), R8W (lowest word), R8B (lowest byte).\n\nHere is a quick overview of the registers\n- AL/AH/AX/EAX/RAX: Accumulator\n- BL/BH/BX/EBX/RBX: Base Index (for array use)\n- CL/CH/CX/ECX/RCX: Counter (loops and strings)\n- DL/DH/DX/EDX/RDX: Extend accumulator precision\n- R8-15/R8-15D/R8-15W/R8-15B: General registers\n- SI/ESI/RSI: Source Index\n- DI/EDI/RDI: Destination index\n- SP/ESP/RSP: Stack Pointer\n- BP/EBP/RBP: Base Stack Pointer\n- IP/EIP/RIP: Instruction Pointer\n- CS: Code Segment\n- DS: Data Segment\n- SS: Stack Segment\n- ES: Extra Segment\n- FS: Extra Segment #2\n- GS: Extra Segment #3\n\n\u003e ## Extra\n\u003e Registers are actually really cool if you look at their implementation. This article does an incredible job of going over the old 8086s instruction register. If you are interested in the hardware aspect of it I recommend giving this a read. [Ken Shirriff's Blog - Latches inside: Reverse-engineering the Intel 8086's instruction regster](http://www.righto.com/2020/08/latches-inside-reverse-engineering.html)\n\n## Real Mode and BIOS\n\nWhen you boot up your computer the CPU starts up in Real Mode, also known as Real Address Mode. The reason for this name is when you access memory you are actually accessing that memory address and not being redirected by memory protection.  There are some pros and cons to being in this mode. \n\nCons\n* The default CPU operand length is 16 bits.\n* No hardware based memory protection or virtual memory.\n* Access to less than 1 MB of RAM.\n\nPros\n* BIOS functions act as low level API functions.\n* BIOS installs device drivers.\n* Faster memory access.\n* Faster CPU speeds due to lack of security overhead.\n\nThe BIOS is the saving grace when it comes to real mode because it takes care of interfacing with hardware and makes jumping to other modes much easier. The BIOS (Basic Input / Output System) was added to provide low-level services to PC system programmers. It does the job of hiding different hardware under a layer of abstraction that makes interfacing with it the same no matter the system. We can access the BIOS functions using interrupts where we set AH to a particular value and call INT #, where # is some predefined number for the interrupt. We will go over the BIOS functions as we need them throughout the series because there are too many to list out.\n\nSome other modes the CPU supports are Virtual 8086 mode, Protected Mode (32-bit), and Long Mode (64-bit). We will see protected mode later on but the immediate effect is we will have to abandon the BIOS and won't be able to use its functions. Virtual 8086 mode is an emulated 16-bit real mode where you may call BIOS functions in protected mode. We don't use this because it has its fair share of problems and why use BIOS when we can program everything from that point on ourselves.\n\n## Memory Layout\n\nThe memory layout is important to keep in mind because if we are not careful we could overwrite BIOS functions or the bootloader itself, which could only throw the system into a downward spiral of chaos. I'm not going to be as descriptive here becuase I can just throw up a table and refer back everytime we need to check.\n\n| Start | End | Description |\n| - | - | - |\n| 0x00000000 | 0x000003FF | Real Mode IVT |\n| 0x00000400 | 0x000004FF | BDA (BIOS Data Area) |\n| 0x00000500 | 0x00007BFF | Conventional Memory |\n| 0x00007C00 | 0x00007DFF | OS Bootsector |\n| 0x00007E00 | 0x0007FFFF | Conventional Memory |\n| 0x00080000 | 0x0009FFFF | EBDA (Extended BIOS Data Area) |\n| 0x000A0000 | 0x000BFFFF | Video Display Memory |\n| 0x000C0000 | 0x000C7FFF | Video BIOS |\n| 0x000C8000 | 0x000EFFFF | BIOS Expansions |\n| 0x000F0000 | 0x000FFFFF | Motherboard BIOS |\n\nWe won't go into the data areas but if you are interested there are plenty of resources that go over them.\n\n#### Bootloader\n\nNow that we've got some pre reqs out of the way we can move on to the actual bootloader. For anyone who is familiar with the bootloader this section will solely be on familiarizing ourselves with assembly, the boot process, and how the bootloader is loaded into memory. We will not be dealing with any second stage bootloader or kernel loading for this section.\n\nWhenever you boot up your computer the first thing it does is run a series of diagnostics called POST (Power On Self Test). This operation checks that all the computer hardware is working correctly before continuing the boot process and searches for all the bootable devices hooked up to the system (Floppy Disk, CD-ROM, Hard Disk, etc.).\n\nOnce your computer is done running POST it moves into verifying the Master Boot Record. This is the content on the first sector of the hard drive and will eventually be where we put our bootloader. To verify that there is a bootloader it looks for the magic number which is stored in the last two bytes of the first sector. If the memory contains the byte sequence 0x55, 0xAA at byte offsets 510 and 511 respectively it can load the bootloader and continue. If it does not see these bytes it will move on to check the next bootable device.\n\nOnce our bootloader is found and verified the computer will load our program into memory location 0x7C00 and our instruction pointer register will be set to the start of the program. With this information out of the way let's finally start programming our first bootloader. Forewarning, this will not be like a normal hello world, we will have to manually program a function to print since we don't have the luxury of ```printf``` or ```std::cout``` *scary*.\n\nWe start with the needed assembler instructions\n\n```x86asm\n[bits 16]\t\t\t; Tells the assembler this is 16-bit code\n[org 0x7c00]\t\t; Tells the assembler it will be in memory at 0x7c00\n```\n\nThese two lines will be added to the first line of your program and will be used by the assembler. The first line tells the assembler to target a 16-bit platform for our code since we will be working in real mode. The second line will tell the assembler to add this offset to all absolute and relative addresses. Since we know where our program will be loaded into memory we can tell the assembler to make sure all addresses point to the correct physical memory.\n\n```\n[bits 16]\t\t\t; Tells the assembler this is 16-bit code\n[org 0x7c00]\t\t; Tells the assembler it will be in memory at 0x7c00\n\njmp $\t\t\t\t; Endlessly jump on this line of code\n\n; Our message we want to print\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\n```\n\nI didn't add much but wanted to explain this portion before I added too much. First, we added our message we want to print at the end of the file. This will be our data section and keeps us from having to jump over it to get to the code. Second, we added jmp $. This instruction tells the program to jump to the same line it is already on (denoted by $) so it will never go into our data section. We want to keep the code from running in the data section because when all this gets compiled into bits it won't know that it is a data section and will try and execute whatever it sees. This could cause our bootloader to go haywire or the computer to just crash so we avoid it.\n\n```\n[bits 16]\t\t\t; Tells the assembler this is 16-bit code\n[org 0x7c00]\t\t; Tells the assembler it will be in memory at 0x7c00\n\njmp $\t\t\t\t; Endlessly jump on this line of code\n\n; Our message we want to print\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\n\n; Fill the end of the file until 510 bytes are filled\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nRemember when I said the computer looks for the magic number at the last two bytes of the bootloader, this is where we add it. We don't really care about what is in between so we can just pad that with zeroes, which is exactly what we do. The first added line will put zeroes at every location from where it starts to where it is specified to end, in our case 510. Then we define a word with the magic number 0xaa55 at byte offsets 510 and 511.\n\n```\n[bits 16]\t\t\t; Tells the assembler this is 16-bit code\n[org 0x7c00]\t\t; Tells the assembler it will be in memory at 0x7c00\n\nmov bp, 0x9000\t\t; Set the base pointer at 0x8000\nmov sp, bp\t\t\t; Set the stack pointer at the base\n\njmp $\t\t\t\t; Endlessly jump on this line of code\n\nprintString_16:\n\n\n; Our message we want to print\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\n\n; Fill the end of the file until 510 bytes are filled\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nNow we have set the base stack pointer and stack pointer to memory location 0x9000. Before I go over the rest, we need to go over a quick thing about the stack. For simplicity, a stack is a linear data structure that follows the last in first out order. We use the terms push and pop to put things on the stack and take them off, respectively. However, the trick is it grows downwards, so our stack will grow from 0x9000 to 0x0000 not 0xFFFF. For our use we won't even get close to overwriting our bootloader and will end up changing the stack and base pointer again very shortly.\n\nWe also define the function printString_16, well we declared the label. I like to declare functions in separate files but to keep this simple we can just combine, eventually we'll be separating them. In case you don't know assembly doesn't really have functions like you know them in other languages. You have labels that you call and return from, or jump to and from, but we will call them. The beauty of calling the function is that call instruction will push the return address (address immediately after the call instruction) onto the stack for us and change EIP to the call destination. Then when we call return it will pop that address off the top of the stack and set EIP to that value. Now we fill out the function.\n\n```\n[bits 16]\t\t\t\t; Tells the assembler this is 16-bit code\n[org 0x7c00]\t\t\t; Tells the assembler it will be in memory at 0x7c00\n\nmov bp, 0x9000\t\t\t; Set the base pointer at 0x9000\nmov sp, bp\t\t\t\t; Set the stack pointer at the base\n\nmov si, MSG_REAL_MODE\t; Move the pointer to the first character to si\ncall printString_16\t\t; Call the print string function\n\njmp $\t\t\t\t\t; Endlessly jump on this line of code\n\nprintString_16:\n\tpusha\t\t\t\t; Push all the registers to the stack\n\tmov ah, 0x0E\t\t; BIOS Subfunction\n\tmov bx, 0x0007\t\t; BH - Page Number / BL - Text Color\n\nnextChar_16:\n\tcmp byte[si], 0\t\t; Compare si to 0 (End of string delimeter)\n\tje stringReturn_16\n\n\tmov al, byte [si] \t; Move the character to print into al\n\tint 0x10\t\t\t; Print Interrupt\n\n\tadd si, 1\t\t\t; Move forward to the next character\n\tjmp nextChar_16\t\t; Jump back to print the next character in the string\n\nstringReturn_16:\n\tmov al, 0x0D\t\t; Move the ASCII code for Carraige Feed into al\n\tint 0x10\t\t\t; Print the character\n\tmov al, 0x0A\t\t; Move the ASCII code for Line Feed into al\n\tint 0x10\t\t\t; Print the character\n\tpopa\t\t\t\t; Pop all the registers from the stack\n\tret\t\t\t\t\t; Return from the function\n\n; Our message we want to print\nMSG_REAL_MODE: db \"Starting up in 16-bit Real Mode.\", 0\n\n; Fill the end of the file until 510 bytes are filled\ntimes 510-($-$$) db 0\ndw 0xaa55\n```\n\nThe first thing we do is go back to our main execution and add two lines, we will move the pointer to the string into si and call the print string function. The great part about registers is that when we set them, unless we explicitly change them, they don't change. It's not like higher level languages with scope so when we get into our print function it'll still be that value. Next, we start writing the printString_16 function. We don't need to do it but it is good practice to save your register values before executing a function, so we call pusha. This is coupled with a popa at the end of the function. Since we do this, whatever registers we change inside the function will be restored when we exit.\n\nThen we set the BIOS subfunction and additional data. When using BIOS interrupts ah will be the subfunction value for the interrupt, and al and bx will be additional data needed for the interrupt. In our case ah is set to 0x0E for the print function, bx is set to 0x0007 (Page Number / Text Color) and al is going to be set to the value to print.\n\nWe then define another label called nextChar_16. This will allow us to loop back and print each character in the string while avoiding code duplication. First, we compare the byte pointed to by si to zero. If the byte is zero that means we have reached the end of the string and need to finish the function. We use the je instruction to jump if the compare is equal. Then we move the byte at si to al and call the interrupt using int 0x10. Luckily for us the interrupt will increment the cursor location for us. After that we add one to si to move forward in memory to the next letter and jump back to the nextChar_16 label to continue printing the string.\n\nFinally, we have the stringReturn_16 label which will end and cleanup our function. We move a carraige feed value into al and print that then load a line feed value into al and print that too (CRLF). Then we return from the function back to the main execution so we can endlessly jump and pause our bootloader.\n\n## Bootloader Compilation\n\nNow we need to compile the program so it can be run by QEMU. Our trusty program NASM shines here. Open up a terminal or command prompt and ```cd``` yourself to the directory your file is in. Run the command\n```\n\u003e nasm bootloader.asm -f bin -o bootloader\n```\nYou can change ```bootloader.asm``` to whatever you named your assembly bootloader file and bootloader to whatever you want your binary file to be named. Now you should see a beautiful binary file with loads of x86_64 opcodes, program data, and padding zeroes.\n\n## Bootloader Testing\n\nNow we can finally test our bootloader in QEMU. Make sure your terminal or command prompt is still open and run the following command.\n\n```\nqemu-system-x86_64 -L C:/Progra~1/qemu -drive format=raw,file=bootloader\n```\n\nNow you should see QEMU open up and display our message we programmed.\n\n\u003e ## Extra\n\u003e Remember that QEMU is a full on emulator so we can actually load this and run it on a computer. I advise you don't run it on your main computer and make sure you know what you are doing so you don't overwrite your Operating System on your main drive. It shouldn't hurt, but you can never be too safe when it comes to something with this lack of hardware security. Personally, I use a simple hard drive to usb adapter to write the bootloader to the first sector of the hard drive. I put the newly written hard drive in an old computer and boot it up. (**BE CAREFUL NOT TO OVERWRITE THE HARD DISK YOU ARE USING. THIS IS REALLY EASY TO DO IF YOU ARE NOT CAREFUL WITH DEVICE NAMES.**)\n\n#### Conclusion\n\nCongratulations! You have just programmed a bootloader and it only gets better from here. In the next section we will be going over a second stage bootloader in preperation for adding a kernel, drivers, video graphics, and more. It may seem we aren't doing anything super interesting at the moment but we are building a strong foundation so we can do cool things later. If you didn't understand something we went over I always suggest researching it some more and getting comfortable with the information. [OS Dev Wiki](https://wiki.osdev.org/Expanded_Main_Page) is an amazing place to check out if you are interested.\n\n[Return to the Posts Page](https://adisonyheathcott.github.io/adison_heathcott/posts)"]]},"__N_SSG":true},"page":"/posts","query":{},"buildId":"FC94lxiNehwQ_u8DzFi0m","assetPrefix":"/adison_heathcott","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/adison_heathcott/_next/static/chunks/polyfills-79441a336eb07a143a5d.js"></script><script src="/adison_heathcott/_next/static/chunks/main-d05829dd66b3e1d8dba3.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/webpack-f9942f282841fa8e3981.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/framework.0c239260661ae1d12aa2.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/a9a7754c.3e676eb972e02f9f394c.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/cb1608f2.3eb57f0c33083404a117.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/b390309770db065fb8b440ac7fc4a6de136d7abc.88a98345373b768921d7.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/b55bc555eab864841adf6c3eb09476da0ca9cc92.430f01b3a08741c3f584.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/pages/_app-1988fd1f277b02054148.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/9f96d65d.1ff5480bc23bdbbc81ff.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/62bb8ee6c2f5191f1fc2bff08a7b84d038648b6c.4314cb0a9e66a7677577.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/c2b541414cb101b874f2f4dc935956aab3eab2d0.3eef0c55f6208d925fd3.js" async=""></script><script src="/adison_heathcott/_next/static/chunks/pages/posts-12ed76fe0122e5f554b0.js" async=""></script><script src="/adison_heathcott/_next/static/FC94lxiNehwQ_u8DzFi0m/_buildManifest.js" async=""></script><script src="/adison_heathcott/_next/static/FC94lxiNehwQ_u8DzFi0m/_ssgManifest.js" async=""></script></body></html>